# Linux Kernel x86-64 System Interface
namespace sys;

# System V x86-64 (LP64) ABI:
# C Type             | Size | Alignment | Sunder Type
# -------------------+------+-----------+------------
# char               | 1    | 1         | byte
# signed   char      | 1    | 1         | s8
# unsigned char      | 1    | 1         | u8
# signed   short     | 2    | 2         | s16
# unsigned short     | 2    | 2         | u16
# signed   int       | 4    | 4         | s32
# unsigned int       | 4    | 4         | u32
# signed   long      | 8    | 8         | ssize
# unsigned long      | 8    | 8         | usize
# signed   long long | 8    | 8         | s64
# unsigned long long | 8    | 8         | u64
#
# POSIX types obtainted through GDB `whatis` on x64 Linux:
# (gdb) whatis blkcnt_t
# type = long
# (gdb) whatis blksize_t
# type = long
# (gdb) whatis clock_t
# type = long
# (gdb) whatis clockid_t
# type = int
# (gdb) whatis dev_t
# type = unsigned long
# (gdb) whatis fsblkcnt_t
# type = unsigned long
# (gdb) whatis fsfilcnt_t
# type = unsigned long
# (gdb) whatis gid_t
# type = unsigned int
# (gdb) whatis id_t
# type = unsigned int
# (gdb) whatis ino_t
# type = unsigned long
# (gdb) whatis key_t
# type = int
# (gdb) whatis mode_t
# type = unsigned int
# (gdb) whatis nlink_t
# type = unsigned long
# (gdb) whatis off_t
# type = long
# (gdb) whatis pid_t
# type = int
# (gdb) whatis size_t
# type = unsigned long
# (gdb) whatis ssize_t
# type = long
# (gdb) whatis suseconds_t
# type = long
# (gdb) whatis time_t
# type = long
# (gdb) whatis timer_t
# type = void *
# (gdb) whatis uid_t
# type = unsigned int
#
# linux/include/linux/types.h:
# typedef unsigned short        umode_t;

alias char      = byte;
alias schar     = s8;
alias uchar     = u8;
alias sshort    = s16;
alias ushort    = u16;
alias sint      = s32;
alias uint      = u32;
alias slong     = ssize;
alias ulong     = usize;
alias slonglong = s64;
alias ulonglong = u64;

alias smax = s64;
alias umax = u64;

alias blkcnt_t    = slong;
alias blksize_t   = slong;
alias clock_t     = slong;
alias clockid_t   = sint;
alias dev_t       = ulong;
alias fsblkcnt_t  = ulong;
alias fsfilcnt_t  = ulong;
alias gid_t       = uint;
alias id_t        = uint;
alias ino_t       = ulong;
alias key_t       = sint;
alias mode_t      = uint;
alias nlink_t     = ulong;
alias off_t       = slong;
alias pid_t       = sint;
alias size_t      = ulong;
alias ssize_t     = slong;
alias suseconds_t = slong;
alias time_t      = slong;
alias timer_t     = *any;
alias uid_t       = uint;

alias umode_t = ushort;

const EPERM:           ssize = 1;
const ENOENT:          ssize = 2;
const ESRCH:           ssize = 3;
const EINTR:           ssize = 4;
const EIO:             ssize = 5;
const ENXIO:           ssize = 6;
const E2BIG:           ssize = 7;
const ENOEXEC:         ssize = 8;
const EBADF:           ssize = 9;
const ECHILD:          ssize = 10;
const EAGAIN:          ssize = 11;
const ENOMEM:          ssize = 12;
const EACCES:          ssize = 13;
const EFAULT:          ssize = 14;
const ENOTBLK:         ssize = 15;
const EBUSY:           ssize = 16;
const EEXIST:          ssize = 17;
const EXDEV:           ssize = 18;
const ENODEV:          ssize = 19;
const ENOTDIR:         ssize = 20;
const EISDIR:          ssize = 21;
const EINVAL:          ssize = 22;
const ENFILE:          ssize = 23;
const EMFILE:          ssize = 24;
const ENOTTY:          ssize = 25;
const ETXTBSY:         ssize = 26;
const EFBIG:           ssize = 27;
const ENOSPC:          ssize = 28;
const ESPIPE:          ssize = 29;
const EROFS:           ssize = 30;
const EMLINK:          ssize = 31;
const EPIPE:           ssize = 32;
const EDOM:            ssize = 33;
const ERANGE:          ssize = 34;
const EDEADLK:         ssize = 35;
const ENAMETOOLONG:    ssize = 36;
const ENOLCK:          ssize = 37;
const ENOSYS:          ssize = 38;
const ENOTEMPTY:       ssize = 39;
const ELOOP:           ssize = 40;
const ENOMSG:          ssize = 42;
const EIDRM:           ssize = 43;
const ECHRNG:          ssize = 44;
const EL2NSYNC:        ssize = 45;
const EL3HLT:          ssize = 46;
const EL3RST:          ssize = 47;
const ELNRNG:          ssize = 48;
const EUNATCH:         ssize = 49;
const ENOCSI:          ssize = 50;
const EL2HLT:          ssize = 51;
const EBADE:           ssize = 52;
const EBADR:           ssize = 53;
const EXFULL:          ssize = 54;
const ENOANO:          ssize = 55;
const EBADRQC:         ssize = 56;
const EBADSLT:         ssize = 57;
const EBFONT:          ssize = 59;
const ENOSTR:          ssize = 60;
const ENODATA:         ssize = 61;
const ETIME:           ssize = 62;
const ENOSR:           ssize = 63;
const ENONET:          ssize = 64;
const ENOPKG:          ssize = 65;
const EREMOTE:         ssize = 66;
const ENOLINK:         ssize = 67;
const EADV:            ssize = 68;
const ESRMNT:          ssize = 69;
const ECOMM:           ssize = 70;
const EPROTO:          ssize = 71;
const EMULTIHOP:       ssize = 72;
const EDOTDOT:         ssize = 73;
const EBADMSG:         ssize = 74;
const EOVERFLOW:       ssize = 75;
const ENOTUNIQ:        ssize = 76;
const EBADFD:          ssize = 77;
const EREMCHG:         ssize = 78;
const ELIBACC:         ssize = 79;
const ELIBBAD:         ssize = 80;
const ELIBSCN:         ssize = 81;
const ELIBMAX:         ssize = 82;
const ELIBEXEC:        ssize = 83;
const EILSEQ:          ssize = 84;
const ERESTART:        ssize = 85;
const ESTRPIPE:        ssize = 86;
const EUSERS:          ssize = 87;
const ENOTSOCK:        ssize = 88;
const EDESTADDRREQ:    ssize = 89;
const EMSGSIZE:        ssize = 90;
const EPROTOTYPE:      ssize = 91;
const ENOPROTOOPT:     ssize = 92;
const EPROTONOSUPPORT: ssize = 93;
const ESOCKTNOSUPPORT: ssize = 94;
const EOPNOTSUPP:      ssize = 95;
const EPFNOSUPPORT:    ssize = 96;
const EAFNOSUPPORT:    ssize = 97;
const EADDRINUSE:      ssize = 98;
const EADDRNOTAVAIL:   ssize = 99;
const ENETDOWN:        ssize = 100;
const ENETUNREACH:     ssize = 101;
const ENETRESET:       ssize = 102;
const ECONNABORTED:    ssize = 103;
const ECONNRESET:      ssize = 104;
const ENOBUFS:         ssize = 105;
const EISCONN:         ssize = 106;
const ENOTCONN:        ssize = 107;
const ESHUTDOWN:       ssize = 108;
const ETOOMANYREFS:    ssize = 109;
const ETIMEDOUT:       ssize = 110;
const ECONNREFUSED:    ssize = 111;
const EHOSTDOWN:       ssize = 112;
const EHOSTUNREACH:    ssize = 113;
const EALREADY:        ssize = 114;
const EINPROGRESS:     ssize = 115;
const ESTALE:          ssize = 116;
const EUCLEAN:         ssize = 117;
const ENOTNAM:         ssize = 118;
const ENAVAIL:         ssize = 119;
const EISNAM:          ssize = 120;
const EREMOTEIO:       ssize = 121;
const EDQUOT:          ssize = 122;
const ENOMEDIUM:       ssize = 123;
const EMEDIUMTYPE:     ssize = 124;
const ECANCELED:       ssize = 125;
const ENOKEY:          ssize = 126;
const EKEYEXPIRED:     ssize = 127;
const EKEYREVOKED:     ssize = 128;
const EKEYREJECTED:    ssize = 129;
const EOWNERDEAD:      ssize = 130;
const ENOTRECOVERABLE: ssize = 131;
const ERFKILL:         ssize = 132;
const EHWPOISON:       ssize = 133;

const ERRORS = (:[][]byte)[
    "[system error 0] Undefined errno value",
    "[system error EPERM] Operation not permitted",
    "[system error ENOENT] No such file or directory",
    "[system error ESRCH] No such process",
    "[system error EINTR] Interrupted system call",
    "[system error EIO] Input/output error",
    "[system error ENXIO] No such device or address",
    "[system error E2BIG] Argument list too long",
    "[system error ENOEXEC] Exec format error",
    "[system error EBADF] Bad file descriptor",
    "[system error ECHILD] No child processes",
    "[system error EAGAIN] Resource temporarily unavailable",
    "[system error ENOMEM] Cannot allocate memory",
    "[system error EACCES] Permission denied",
    "[system error EFAULT] Bad address",
    "[system error ENOTBLK] Block device required",
    "[system error EBUSY] Device or resource busy",
    "[system error EEXIST] File exists",
    "[system error EXDEV] Invalid cross-device link",
    "[system error ENODEV] No such device",
    "[system error ENOTDIR] Not a directory",
    "[system error EISDIR] Is a directory",
    "[system error EINVAL] Invalid argument",
    "[system error ENFILE] Too many open files in system",
    "[system error EMFILE] Too many open files",
    "[system error ENOTTY] Inappropriate ioctl for device",
    "[system error ETXTBSY] Text file busy",
    "[system error EFBIG] File too large",
    "[system error ENOSPC] No space left on device",
    "[system error ESPIPE] Illegal seek",
    "[system error EROFS] Read-only file system",
    "[system error EMLINK] Too many links",
    "[system error EPIPE] Broken pipe",
    "[system error EDOM] Numerical argument out of domain",
    "[system error ERANGE] Numerical result out of range",
    "[system error EDEADLK] Resource deadlock avoided",
    "[system error ENAMETOOLONG] File name too long",
    "[system error ENOLCK] No locks available",
    "[system error ENOSYS] Function not implemented",
    "[system error ENOTEMPTY] Directory not empty",
    "[system error ELOOP] Too many levels of symbolic links",
    "[system error 41] Undefined errno value",
    "[system error ENOMSG] No message of desired type",
    "[system error EIDRM] Identifier removed",
    "[system error ECHRNG] Channel number out of range",
    "[system error EL2NSYNC] Level 2 not synchronized",
    "[system error EL3HLT] Level 3 halted",
    "[system error EL3RST] Level 3 reset",
    "[system error ELNRNG] Link number out of range",
    "[system error EUNATCH] Protocol driver not attached",
    "[system error ENOCSI] No CSI structure available",
    "[system error EL2HLT] Level 2 halted",
    "[system error EBADE] Invalid exchange",
    "[system error EBADR] Invalid request descriptor",
    "[system error EXFULL] Exchange full",
    "[system error ENOANO] No anode",
    "[system error EBADRQC] Invalid request code",
    "[system error EBADSLT] Invalid slot",
    "[system error 58] Undefined errno value",
    "[system error EBFONT] Bad font file format",
    "[system error ENOSTR] Device not a stream",
    "[system error ENODATA] No data available",
    "[system error ETIME] Timer expired",
    "[system error ENOSR] Out of streams resources",
    "[system error ENONET] Machine is not on the network",
    "[system error ENOPKG] Package not installed",
    "[system error EREMOTE] Object is remote",
    "[system error ENOLINK] Link has been severed",
    "[system error EADV] Advertise error",
    "[system error ESRMNT] Srmount error",
    "[system error ECOMM] Communication error on send",
    "[system error EPROTO] Protocol error",
    "[system error EMULTIHOP] Multihop attempted",
    "[system error EDOTDOT] RFS specific error",
    "[system error EBADMSG] Bad message",
    "[system error EOVERFLOW] Value too large for defined data type",
    "[system error ENOTUNIQ] Name not unique on network",
    "[system error EBADFD] File descriptor in bad state",
    "[system error EREMCHG] Remote address changed",
    "[system error ELIBACC] Can not access a needed shared library",
    "[system error ELIBBAD] Accessing a corrupted shared library",
    "[system error ELIBSCN] .lib section in a.out corrupted",
    "[system error ELIBMAX] Attempting to link in too many shared libraries",
    "[system error ELIBEXEC] Cannot exec a shared library directly",
    "[system error EILSEQ] Invalid or incomplete multibyte or wide character",
    "[system error ERESTART] Interrupted system call should be restarted",
    "[system error ESTRPIPE] Streams pipe error",
    "[system error EUSERS] Too many users",
    "[system error ENOTSOCK] Socket operation on non-socket",
    "[system error EDESTADDRREQ] Destination address required",
    "[system error EMSGSIZE] Message too long",
    "[system error EPROTOTYPE] Protocol wrong type for socket",
    "[system error ENOPROTOOPT] Protocol not available",
    "[system error EPROTONOSUPPORT] Protocol not supported",
    "[system error ESOCKTNOSUPPORT] Socket type not supported",
    "[system error EOPNOTSUPP] Operation not supported",
    "[system error EPFNOSUPPORT] Protocol family not supported",
    "[system error EAFNOSUPPORT] Address family not supported by protocol",
    "[system error EADDRINUSE] Address already in use",
    "[system error EADDRNOTAVAIL] Cannot assign requested address",
    "[system error ENETDOWN] Network is down",
    "[system error ENETUNREACH] Network is unreachable",
    "[system error ENETRESET] Network dropped connection on reset",
    "[system error ECONNABORTED] Software caused connection abort",
    "[system error ECONNRESET] Connection reset by peer",
    "[system error ENOBUFS] No buffer space available",
    "[system error EISCONN] Transport endpoint is already connected",
    "[system error ENOTCONN] Transport endpoint is not connected",
    "[system error ESHUTDOWN] Cannot send after transport endpoint shutdown",
    "[system error ETOOMANYREFS] Too many references: cannot splice",
    "[system error ETIMEDOUT] Connection timed out",
    "[system error ECONNREFUSED] Connection refused",
    "[system error EHOSTDOWN] Host is down",
    "[system error EHOSTUNREACH] No route to host",
    "[system error EALREADY] Operation already in progress",
    "[system error EINPROGRESS] Operation now in progress",
    "[system error ESTALE] Stale file handle",
    "[system error EUCLEAN] Structure needs cleaning",
    "[system error ENOTNAM] Not a XENIX named type file",
    "[system error ENAVAIL] No XENIX semaphores available",
    "[system error EISNAM] Is a named type file",
    "[system error EREMOTEIO] Remote I/O error",
    "[system error EDQUOT] Disk quota exceeded",
    "[system error ENOMEDIUM] No medium found",
    "[system error EMEDIUMTYPE] Wrong medium type",
    "[system error ECANCELED] Operation canceled",
    "[system error ENOKEY] Required key not available",
    "[system error EKEYEXPIRED] Key has expired",
    "[system error EKEYREVOKED] Key has been revoked",
    "[system error EKEYREJECTED] Key was rejected by service",
    "[system error EOWNERDEAD] Owner died",
    "[system error ENOTRECOVERABLE] State not recoverable",
    "[system error ERFKILL] Operation not possible due to RF-kill",
    "[system error EHWPOISON] Memory page has hardware error"
];

const STDIN_FILENO:  uint = 0;
const STDOUT_FILENO: uint = 1;
const STDERR_FILENO: uint = 2;

const O_RDONLY:    sint = 0x00000000;
const O_WRONLY:    sint = 0x00000001;
const O_RDWR:      sint = 0x00000002;
const O_CREAT:     sint = 0x00000040;
const O_EXCL:      sint = 0x00000080;
const O_NOCTTY:    sint = 0x00000100;
const O_TRUNC:     sint = 0x00000200;
const O_APPEND:    sint = 0x00000400;
const O_CLOEXEC:   sint = 0x00080000;
const O_DIRECTORY: sint = 0x00010000;
const O_NOFOLLOW:  sint = 0x00020000;
const O_NONBLOCK:  sint = 0x00000800;
const O_DSYNC:     sint = 0x00001000;
const O_RSYNC:     sint = 0x00101000;
const O_SYNC:      sint = 0x00101000;

const S_IRWXU: umode_t = 0o700;
const S_IRUSR: umode_t = 0o400;
const S_IWUSR: umode_t = 0o200;
const S_IXUSR: umode_t = 0o100;

const S_IRWXG: umode_t = 0o070;
const S_IRGRP: umode_t = 0o040;
const S_IWGRP: umode_t = 0o020;
const S_IXGRP: umode_t = 0o010;

const S_IRWXO: umode_t = 0o007;
const S_IROTH: umode_t = 0o004;
const S_IWOTH: umode_t = 0o002;
const S_IXOTH: umode_t = 0o001;

const SEEK_SET: uint = 0x0;
const SEEK_CUR: uint = 0x1;
const SEEK_END: uint = 0x2;

const F_OK: sint = 0b000;
const R_OK: sint = 0b100;
const W_OK: sint = 0b010;
const X_OK: sint = 0b001;

const PROT_NONE:  ulong = 0x0;
const PROT_READ:  ulong = 0x1;
const PROT_WRITE: ulong = 0x2;
const PROT_EXEC:  ulong = 0x4;

const MAP_SHARED:    ulong = 0x01;
const MAP_PRIVATE:   ulong = 0x02;
const MAP_FIXED:     ulong = 0x10;
const MAP_ANONYMOUS: ulong = 0x20;

# linux/include/uapi/linux/limits.h:
const NGROUPS_MAX:    usize =  65536; # supplemental group IDs are available
const ARG_MAX:        usize = 131072; # # bytes of args + environ for exec()
const LINK_MAX:       usize =    127; # # links a file may have
const MAX_CANON:      usize =    255; # size of the canonical input queue
const MAX_INPUT:      usize =    255; # size of the type-ahead buffer
const NAME_MAX:       usize =    255; # # chars in a file name
const PATH_MAX:       usize =   4096; # # chars in a path name including nul
const PIPE_BUF:       usize =   4096; # # bytes in atomic write to a pipe
const XATTR_NAME_MAX: usize =    255; # # chars in an extended attribute name
const XATTR_SIZE_MAX: usize =  65536; # size of an extended attribute value (64k)
const XATTR_LIST_MAX: usize =  65536; # size of extended attribute namelist (64k)

# linux/arch/x86/include/asm/page_types.h:
# PAGE_SIZE is defined in terms of PAGE_SHIFT (12 on x86 and x64).
const PAGE_SIZE: usize = 4096;

struct timespec {
    var tv_sec:     time_t;
    var tv_nsec:    slong;
}

struct timeval {
    var tv_sec:     time_t;
    var tv_usec:    suseconds_t;
}

# The definition of the `struct stat` type appears to have different
# (incompatible) definitions depending on where you look:
#
# + struct stat              => linux/include/uapi/asm-generic/stat.h
# + struct __old_kernel_stat => linux/fs/stat.c
# + struct stat              => glibc/sysdeps/unix/sysv/linux/bits/struct_stat.h
# + struct stat              => musl/arch/x86_64/bits/stat.h
#
# Of these, glibc and musl seem to contain the only definitions that do not
# corrupt the stack, and both have `sizeof(struct stat) == 144` on x64 Linux.
# This definition is modeled after the musl definition.
#
# (dbg) ptype/o struct stat
# /* offset    |  size */  type = struct stat {
# /*    0      |     8 */    dev_t st_dev;
# /*    8      |     8 */    ino_t st_ino;
# /*   16      |     8 */    nlink_t st_nlink;
# /*   24      |     4 */    mode_t st_mode;
# /*   28      |     4 */    uid_t st_uid;
# /*   32      |     4 */    gid_t st_gid;
# /*   36      |     4 */    unsigned int __pad0;
# /*   40      |     8 */    dev_t st_rdev;
# /*   48      |     8 */    off_t st_size;
# /*   56      |     8 */    blksize_t st_blksize;
# /*   64      |     8 */    blkcnt_t st_blocks;
# /*   72      |    16 */    struct timespec {
# /*   72      |     8 */        time_t tv_sec;
# /*   80      |     8 */        long tv_nsec;
#
#                                /* total size (bytes):   16 */
#                            } st_atim;
# /*   88      |    16 */    struct timespec {
# /*   88      |     8 */        time_t tv_sec;
# /*   96      |     8 */        long tv_nsec;
#
#                                /* total size (bytes):   16 */
#                            } st_mtim;
# /*  104      |    16 */    struct timespec {
# /*  104      |     8 */        time_t tv_sec;
# /*  112      |     8 */        long tv_nsec;
#
#                                /* total size (bytes):   16 */
#                            } st_ctim;
# /*  120      |    24 */    long __unused[3];
#
#                            /* total size (bytes):  144 */
#                          }
struct stat_type {
    var st_dev:         dev_t;      # Device.
    var st_ino:         ino_t;      # File serial number.
    var st_nlink:       nlink_t;    # Link count.
    var st_mode:        mode_t;     # File mode.
    var st_uid:         uid_t;      # User ID of the file's owner.
    var st_gid:         gid_t;      # Group ID of the file's group.
    var __pad0:         uint;
    var st_rdev:        dev_t;      # Device number, if device.
    var st_size:        off_t;      # Size of file, in bytes.
    var st_blksize:     blksize_t;  # Optimal block size for I/O.
    var st_blocks:      blkcnt_t;   # Number 512-byte blocks allocated.
    var st_atim:        timespec;   # Time of last access.
    var st_mtime:       timespec;   # Time of last modification.
    var st_ctime:       timespec;   # Time of last status change.
    var __unused:       [3]slong;
}

const S_IFMT:   mode_t = 0o170000; # Mask for S_I* file modes.
const S_IFBLK:  mode_t = 0o060000; # Block special.
const S_IFCHR:  mode_t = 0o020000; # Character special.
const S_IFIFO:  mode_t = 0o010000; # FIFO special.
const S_IFREG:  mode_t = 0o100000; # Regular.
const S_IFDIR:  mode_t = 0o040000; # Directory.
const S_IFLNK:  mode_t = 0o120000; # Symbolic link.
const S_IFSOCK: mode_t = 0o140000; # Socket.

func S_ISBLK (mode: mode_t) bool { return (mode & S_IFMT) == S_IFBLK;  }
func S_ISCHR (mode: mode_t) bool { return (mode & S_IFMT) == S_IFCHR;  }
func S_ISDIR (mode: mode_t) bool { return (mode & S_IFMT) == S_IFDIR;  }
func S_ISFIFO(mode: mode_t) bool { return (mode & S_IFMT) == S_IFIFO;  }
func S_ISLNK (mode: mode_t) bool { return (mode & S_IFMT) == S_IFLNK;  }
func S_ISREG (mode: mode_t) bool { return (mode & S_IFMT) == S_IFREG;  }
func S_ISSOCK(mode: mode_t) bool { return (mode & S_IFMT) == S_IFSOCK; }

# (gdb) ptype/o struct rusage
# /* offset    |  size */  type = struct rusage {
# /*    0      |    16 */    struct timeval {
# /*    0      |     8 */        time_t tv_sec;
# /*    8      |     8 */        suseconds_t tv_usec;
#
#                                /* total size (bytes):   16 */
#                            } ru_utime;
# /*   16      |    16 */    struct timeval {
# /*   16      |     8 */        time_t tv_sec;
# /*   24      |     8 */        suseconds_t tv_usec;
#
#                                /* total size (bytes):   16 */
#                            } ru_stime;
# /*   32      |     8 */    long ru_maxrss;
# /*   40      |     8 */    long ru_ixrss;
# /*   48      |     8 */    long ru_idrss;
# /*   56      |     8 */    long ru_isrss;
# /*   64      |     8 */    long ru_minflt;
# /*   72      |     8 */    long ru_majflt;
# /*   80      |     8 */    long ru_nswap;
# /*   88      |     8 */    long ru_inblock;
# /*   96      |     8 */    long ru_oublock;
# /*  104      |     8 */    long ru_msgsnd;
# /*  112      |     8 */    long ru_msgrcv;
# /*  120      |     8 */    long ru_nsignals;
# /*  128      |     8 */    long ru_nvcsw;
# /*  136      |     8 */    long ru_nivcsw;
# /*  144      |   128 */    long __reserved[16];
#
#                            /* total size (bytes):  272 */
#                          }
struct rusage {
    var ru_utime:       timeval;
    var ru_stime:       timeval;
    var ru_maxrss:      slong;
    var ru_ixrss:       slong;
    var ru_idrss:       slong;
    var ru_isrss:       slong;
    var ru_minflt:      slong;
    var ru_majflt:      slong;
    var ru_nswap:       slong;
    var ru_inblock:     slong;
    var ru_oublock:     slong;
    var ru_msgsnd:      slong;
    var ru_msgrcv:      slong;
    var ru_nsignals:    slong;
    var ru_nvcsw:       slong;
    var ru_nivcsw:      slong;
    var __reserved:     [16]slong;
}

# linux/fs/readdir.c:
### struct linux_dirent {
###     unsigned long   d_ino;
###     unsigned long   d_off;
###     unsigned short  d_reclen;
###     char            d_name[1];
### };
struct linux_dirent {
    var d_ino: ulong;
    var d_off: ulong;
    var d_reclen: ushort;
    var d_name: byte;
}

extern func read(fd: uint, buf: *char, count: usize) ssize;
extern func write(fd: uint, buf: *char, count: usize) ssize;
extern func open(filename: *char, flags: sint, mode: umode_t) ssize;
extern func close(fd: uint) ssize;
extern func stat(filename: *byte, statbuf: *stat_type) ssize;
extern func lseek(fd: uint, offset: off_t, whence: uint) ssize;
extern func mmap(addr: ulong, len: ulong, prot: ulong, flags: ulong, fd: ulong, off: ulong) ssize;
extern func munmap(addr: ulong, len: usize) ssize;
extern func access(filename: *byte, mode: sint) ssize;
extern func fork() ssize;
extern func execve(filename: *byte, argv: **byte, envp: **byte) ssize;
extern func exit(error_code: sint) void;
extern func wait4(upid: pid_t, stat_addr: *sint, options: sint, ru: *rusage) ssize;
extern func getdents(fd: uint, dirent: *linux_dirent, count: uint) ssize;
extern func mkdir(pathname: *byte, mode: umode_t) ssize;
extern func rmdir(pathname: *byte) ssize;
extern func unlink(pathname: *byte) ssize;

# linux/tools/include/nolibc/nolibc.h:
# #define WEXITSTATUS(status)   (((status) & 0xff00) >> 8)
func WEXITSTATUS(status: sint) sint {
    return (status & 0xff00) / 256;
}

extern var argc: usize;
extern var argv: **byte;
extern var envp: **byte;

extern func wrapping_add(lhs: usize, rhs: usize) usize;
extern func wrapping_sub(lhs: usize, rhs: usize) usize;
extern func wrapping_mul(lhs: usize, rhs: usize) usize;
