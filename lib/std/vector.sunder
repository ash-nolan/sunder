namespace std;
import "std/core.sunder";

# Managed dynamic array type.
struct vector[[T]] {
    var _allocator: std::allocator;
    var _start: *T;
    var _count: usize;
    var _capacity: usize;

    # Initialize a vector with a count and capacity of zero.
    func init(allocator: std::allocator) vector[[T]] {
        return (:vector[[T]]){
            ._allocator = allocator,
            ._start = (:*T)0u,
            ._count = 0,
            ._capacity = 0
        };
    }

    # Finalize resources associated with the vector.
    func fini(self: *vector[[T]]) void {
        if self.*._capacity != 0 {
            std::slice[[T]]::delete(self.*._allocator, (:[]T){self.*._start, self.*._capacity});
        }
    }

    # Returns a pointer to the first element of the vector.
    func start(self: *vector[[T]]) *T {
        return self.*._start;
    }

    # Returns the number of elements in the vector.
    func count(self: *vector[[T]]) usize {
        return self.*._count;
    }

    # Returns the number of elements the vector can hold without reallocating.
    func capacity(self: *vector[[T]]) usize {
        return self.*._capacity;
    }

    # Returns a view of the vector elements.
    func data(self: *vector[[T]]) []T {
        return (:[]T){self.*._start, self.*._count};
    }

    # Reserve storage such that the vector can hold at least `capacity`
    # elements without reallocating.
    func reserve(self: *vector[[T]], capacity: usize) void {
        if capacity <= self.*._capacity {
            return;
        }

        if self.*._capacity == 0 {
            var new = std::slice[[T]]::new(self.*._allocator, capacity);
            self.*._start = &new[0];
            self.*._capacity = capacity;
            return;
        }

        var cur = (:[]T){self.*._start, self.*._capacity};
        var new = std::slice[[T]]::resize(self.*._allocator, cur, capacity);
        self.*._start = &new[0];
        self.*._capacity = capacity;
    }

    # Resize the vector to `count` elements.
    func resize(self: *vector[[T]], count: usize) void {
        if count > self.*._capacity {
            self.*.reserve(count);
        }

        self.*._count = count;
    }

    # Insert `value` into the vector at position `index`. Calling
    # `std::vector::insert` with `index` equal to the count of the vector is
    # equivalent to calling `std::vector::push` with the provided value.
    #
    # Panics if the provided index is greater than the count of the vector.
    func insert(self: *vector[[T]], index: usize, value: T) void {
        if index > self.*._count {
            std::panic("invalid index");
        }

        if self.*._count == 0 {
            self.*.resize(1);
            self.*.data()[0] = value;
            return;
        }

        # [A][B][C][D][E]
        # [A][B][C][D][E][ ]
        if self.*._count == self.*._capacity {
            const GROWTH_FACTOR: usize = 2;
            self.*.reserve(self.*._capacity * GROWTH_FACTOR);
        }

        # [A][B][C][D][E][ ]
        # [A][B][ ][C][D][E]
        var n: usize = self.*._count - index;
        var mem: []T = (:[]T){self.*._start, self.*._capacity};
        var src: []T = mem[index     : index + n];
        var dst: []T = mem[index + 1 : index + n + 1];
        std::slice[[T]]::copy(dst, src);
        self.*._count = self.*._count + 1;

        # [A][B][ ][C][D][E]
        # [A][B][X][C][D][E]
        self.*.data()[index] = value;
    }

    # Removes and returns the element from the vector at posisiton `index`.
    #
    # Panics if the provided index is out of bounds.
    func remove(self: *vector[[T]], index: usize) T {
        if index >= self.*._count {
            std::panic("invalid index");
        }

        # [A][B][X][C][D][E]
        # [A][B][C][D][E][ ]
        var n: usize = (self.*._count - 1) - index;
        var mem: []T = (:[]T){self.*._start, self.*._capacity};
        var src: []T = mem[index + 1 : index + n + 1];
        var dst: []T = mem[index     : index + n];
        var res = mem[index];
        std::slice[[T]]::copy(dst, src);
        self.*._count = self.*._count - 1;
        return res;
    }

    # Append `value` to the end of the vector.
    func push(self: *vector[[T]], value: T) void {
        self.*.insert(self.*._count, value);
    }

    # Removes and returns the last element of the vector.
    func pop(self: *vector[[T]]) T {
        if self.*._count == 0 {
            std::panic("attempted to pop empty vector");
        }
        return self.*.remove(self.*._count - 1);
    }
}
