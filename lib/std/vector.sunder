namespace std;
import "std/core.sunder";

struct vector[[T]] {
    var _allocator: std::allocator;
    var _start: *T;
    var _count: usize;
    var _capacity: usize;

    func init(allocator: std::allocator) vector[[T]] {
        return (:vector[[T]]){
            ._allocator = allocator,
            ._start = (:*T)0u,
            ._count = 0,
            ._capacity = 0
        };
    }

    func fini(self: *vector[[T]]) void {
        if self.*._capacity != 0 {
            std::delete_slice[[T]](self.*._allocator, (:[]T){self.*._start, self.*._capacity});
        }
    }

    func start(self: *vector[[T]]) *T {
        return self.*._start;
    }

    func count(self: *vector[[T]]) usize {
        return self.*._count;
    }

    func capacity(self: *vector[[T]]) usize {
        return self.*._capacity;
    }

    func data(self: *vector[[T]]) []T {
        return (:[]T){self.*._start, self.*._count};
    }

    func reserve(self: *vector[[T]], capacity: usize) void {
        if capacity <= self.*._capacity {
            return;
        }

        if self.*._capacity == 0 {
            var new = std::new_slice[[T]](self.*._allocator, capacity);
            self.*._start = &new[0];
            self.*._capacity = capacity;
            return;
        }

        var cur = (:[]T){self.*._start, self.*._capacity};
        var new = std::resize_slice[[T]](self.*._allocator, cur, capacity);
        self.*._start = &new[0];
        self.*._capacity = capacity;
    }

    func resize(self: *vector[[T]], count: usize) void {
        if count > self.*._capacity {
            self.*.reserve(count);
        }

        self.*._count = count;
    }

    func insert(self: *vector[[T]], index: usize, value: T) void {
        if index > self.*._count {
            std::panic("invalid index");
        }

        if self.*._count == 0 {
            self.*.resize(1);
            self.*.data()[0] = value;
            return;
        }

        # [A][B][C][D][E]
        # [A][B][C][D][E][ ]
        if self.*._count == self.*._capacity {
            const GROWTH_FACTOR: usize = 2;
            self.*.reserve(self.*._capacity * GROWTH_FACTOR);
        }

        # [A][B][C][D][E][ ]
        # [A][B][ ][C][D][E]
        var n: usize = self.*._count - index;
        var mem: []T = (:[]T){self.*._start, self.*._capacity};
        var src: []T = mem[index     : index + n];
        var dst: []T = mem[index + 1 : index + n + 1];
        std::copy_slice[[T]](dst, src);
        self.*._count = self.*._count + 1;

        # [A][B][ ][C][D][E]
        # [A][B][X][C][D][E]
        self.*.data()[index] = value;
    }

    func remove(self: *vector[[T]], index: usize) T {
        if index >= self.*._count {
            std::panic("invalid index");
        }

        # [A][B][X][C][D][E]
        # [A][B][C][D][E][ ]
        var n: usize = (self.*._count - 1) - index;
        var mem: []T = (:[]T){self.*._start, self.*._capacity};
        var src: []T = mem[index + 1 : index + n + 1];
        var dst: []T = mem[index     : index + n];
        var res = mem[index];
        std::copy_slice[[T]](dst, src);
        self.*._count = self.*._count - 1;
        return res;
    }

    func push(self: *vector[[T]], value: T) void {
        self.*.insert(self.*._count, value);
    }

    func pop(self: *vector[[T]]) T {
        if self.*._count == 0 {
            std::panic("attempted to pop empty vector");
        }
        return self.*.remove(self.*._count - 1);
    }
}
