namespace std;
import "std/core.sunder";

# Managed dynamic byte string type.
struct string {
    var _allocator: std::allocator;
    var _start: *byte;
    var _count: usize;
    var _capacity: usize;

    # Initialize a string with a count and capacity of zero.
    func init(allocator: std::allocator) string {
        return (:string){
            ._allocator = allocator,
            ._start = (:*byte)0u,
            ._count = 0,
            ._capacity = 0
        };
    }

    # Initialize a string as a copy of `str`.
    func init_from_str(allocator: std::allocator, str: []byte) string {
        var self = string::init(allocator);
        std::print(std::writer::init[[std::string]](&self), str);
        return self;
    }

    # Initialize a string from the provided format.
    func init_from_format(allocator: std::allocator, format: []byte, args: []std::formatter) string {
        var self = string::init(allocator);
        std::print_format(std::writer::init[[std::string]](&self), format, args);
        return self;
    }

    # Finalize resources assocaited with the string.
    func fini(self: *string) void {
        if self.*._capacity != 0 {
            std::slice[[byte]]::delete(self.*._allocator, (:[]byte){self.*._start, self.*._capacity});
        }
    }

    # Returns a pointer to the first byte of the string.
    func start(self: *string) *byte {
        return self.*._start;
    }

    # Returns the number of bytes in the string.
    func count(self: *string) usize {
        return self.*._count;
    }

    # Returns the number of bytes the string can hold without reallocating.
    func capacity(self: *string) usize {
        return self.*._capacity;
    }

    # Returns a view of the string bytes.
    func data(self: *string) []byte {
        return (:[]byte){self.*._start, self.*._count};
    }

    # Compares the strings as if they were byte slices.
    func compare(lhs: *string, rhs: *string) ssize {
        var lhs_data = lhs.*.data();
        var rhs_data = rhs.*.data();
        return lhs_data.compare(&rhs_data);
    }

    # Hashes the string as if it were a byte slice.
    func hash(self: *string) usize {
        var data = self.*.data();
        return data.hash();
    }

    # Formats the string as if it were a byte slice using the same format
    # specifiers as the `[]byte` format function.
    func format(self: *string, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        var data = self.*.data();
        return data.format(writer, fmt);
    }

    # Reserve storage such that the string can hold at least `capacity`
    # bytes without reallocating.
    func reserve(self: *string, capacity: usize) void {
        if capacity <= self.*._capacity {
            return;
        }

        if self.*._capacity == 0 {
            var new = std::slice[[byte]]::new(self.*._allocator, capacity);
            self.*._start = &new[0];
            self.*._capacity = capacity;
            return;
        }

        var cur = (:[]byte){self.*._start, self.*._capacity};
        var new = std::slice[[byte]]::resize(self.*._allocator, cur, capacity);
        self.*._start = &new[0];
        self.*._capacity = capacity;
    }

    # Resize the string to `count` bytes.
    func resize(self: *string, count: usize) void {
        if count > self.*._capacity {
            self.*.reserve(count);
        }

        self.*._count = count;
    }

    # Implements the writer interface.
    func write(self: *string, buf: []byte) std::result[[usize, std::error]] {
        var end = self.*._count;
        self.*.resize(end + countof(buf));
        std::slice[[byte]]::copy(self.*.data()[end : end + countof(buf)], buf);
        return std::result[[usize, std::error]]::init_value(countof(buf));
    }
}
