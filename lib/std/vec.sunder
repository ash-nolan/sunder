namespace std;
import "std/core.sunder";

struct vec[[:T]] {
    var _allocator: *std::allocator;
    var _start: *T;
    var _count: usize;
    var _capacity: usize;

    func init(allocator: *std::allocator) std::vec[[:T]] {
        return (:std::vec[[:T]]){
            ._allocator = allocator,
            ._start = (:*T)0u,
            ._count = 0,
            ._capacity = 0
        };
    }

    func fini(self: *std::vec[[:T]]) void {
        std::delete_slice[[:T]](
            self.*._allocator,
            (:[]T){self.*._start, self.*._capacity});
    }

    func start(self: *std::vec[[:T]]) *T {
        return self.*._start;
    }

    func count(self: *std::vec[[:T]]) usize {
        return self.*._count;
    }

    func capacity(self: *std::vec[[:T]]) usize {
        return self.*._capacity;
    }

    func data(self: *std::vec[[:T]]) []T {
        return (:[]T){self.*._start, self.*._count};
    }

    func reserve(self: *std::vec[[:T]], capacity: usize) void {
        if capacity <= self.*._capacity {
            return;
        }

        var cur: []T = (:[]T){self.*._start, self.*._capacity};
        var new: []T = std::resize_slice[[:T]](
            self.*._allocator, cur, capacity);

        self.*._start = &new[0];
        self.*._capacity = capacity;
    }

    func resize(self: *std::vec[[:T]], count: usize) void {
        if count > self.*._capacity {
            self.*.reserve(count);
        }

        self.*._count = count;
    }

    func insert(self: *std::vec[[:T]], index: usize, value: T) void {
        if index > self.*._count {
            std::panic("invalid index");
        }

        if self.*._count == 0 {
            self.*.resize(1);
            self.*.data()[0] = value;
            return;
        }

        # [A][B][C][D][E]
        # [A][B][C][D][E][ ]
        if self.*._count == self.*._capacity {
            const GROWTH_FACTOR: usize = 2;
            self.*.reserve(self.*._capacity * GROWTH_FACTOR);
        }

        # [A][B][C][D][E][ ]
        # [A][B][ ][C][D][E]
        var n: usize = self.*._count - index;
        var mem: []T = (:[]T){self.*._start, self.*._capacity};
        var src: []T = mem[index     : index + n];
        var dst: []T = mem[index + 1 : index + n + 1];
        std::copy_slice[[:T]](dst, src);
        self.*._count = self.*._count + 1;

        # [A][B][ ][C][D][E]
        # [A][B][X][C][D][E]
        self.*.data()[index] = value;
    }

    func remove(self: *std::vec[[:T]], index: usize) void {
        if index >= self.*._count {
            std::panic("invalid index");
        }

        # [A][B][X][C][D][E]
        # [A][B][C][D][E][ ]
        var n: usize = (self.*._count - 1) - index;
        var mem: []T = (:[]T){self.*._start, self.*._capacity};
        var src: []T = mem[index + 1 : index + n + 1];
        var dst: []T = mem[index     : index + n];
        std::copy_slice[[:T]](dst, src);
        self.*._count = self.*._count - 1;
    }

    func push(self: *std::vec[[:T]], value: T) void {
        self.*.insert(self.*._count, value);
    }

    func pop(self: *std::vec[[:T]]) void {
        if self.*._count == 0 {
            std::panic("attempted to pop empty vec");
        }
        self.*.remove(self.*._count - 1);
    }
}
