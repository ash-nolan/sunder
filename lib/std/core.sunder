namespace std;
import "sys";

alias umax = sys::umax;
alias smax = sys::smax;

struct ptr[[T]] { # namespace
    var __namespace__: any;

    # Returns true if the provided pointer is null.
    func is_null(ptr: *T) bool {
        return (:usize)ptr == 0;
    }

    # Returns the null pointer value for type `*T`.
    func null() *T {
        return (:*T)0u;
    }

    # Equivalent to the C operation `ptr + n`.
    func add(ptr: *T, n: usize) *T {
        return (:*T)((:usize)ptr + n * sizeof(typeof(*ptr)));
    }

    # Equivalent to the C operation `ptr - n`.
    func sub(ptr: *T, n: usize) *T {
        return (:*T)((:usize)ptr - n * sizeof(typeof(*ptr)));
    }
}

struct slice[[T]] { # namespace
    var __namespace__: any;

    # Copy the elements of `source` into `destination`. The source and
    # destination buffers must contain the same number of elements.
    func copy(destination: []T, source: []T) void {
        if countof(destination) != countof(source) {
            std::panic("source and destination buffers have different sizes");
        }

        if countof(source) == 0 {
            # Nothing to copy.
            return;
        }

        # If the copy operation is being performed on two slices into the same
        # buffer then the direction in which the copy is performed does matter.
        # Say there is some buffer:
        #
        #    0  1  2  3  4
        #   [A][B][C][D][E]
        #
        # and the following copy operation is performed:
        #
        #   std::slice[[T]]::copy(buf[0:3], buf[1:4]);
        #
        # With a forwards copy the correct result is produced:
        #
        #    0  1  2  3  4
        #   [A][B][C][D][E] <- initial buffer
        #   [B][B][C][D][E] <- copy first element
        #   [B][C][C][D][E] <- copy second element
        #   [B][C][D][D][E] <- copy third element
        #
        # But with a backwards copy an incorrect result is produced:
        #
        #    0  1  2  3  4
        #   [A][B][C][D][E] <- initial buffer
        #   [A][B][D][D][E] <- copy first element
        #   [A][D][D][D][E] <- copy second element
        #   [D][D][D][D][E] <- copy third element
        #
        # So when the start of `destination` appears before the start of
        # `source` the copy must be performed forwards, and when the start of
        # `source` appears before the start of `destination` then copy must be
        # performed backwards. When the start of `destination` and the start of
        # `source` are the same, the copy is arbitrarily chosen to be performed
        # forwards.
        if &destination[0] <= &source[0] {
            # Copy forwards.
            for i in countof(source) {
                destination[i] = source[i];
            }
        }
        else {
            # Copy backwards.
            for i in countof(source) {
                var index: usize = countof(source) - 1 - i;
                destination[index] = source[index];
            }
        }
    }

    # Set every element of the provided slice to the provided value.
    func fill(slice: []T, value: T) void {
        for i in countof(slice) {
            slice[i] = value;
        }
    }

    # Allocate a slice of `count` elements using the provided allocator.
    func new(allocator: std::allocator, count: usize) []T {
        var result = allocator.allocate(alignof(T), count * sizeof(T));
        if result.is_error() {
            std::panic(result.error().*.data);
        }
        return (:[]T){(:*T)result.value(), count};
    }

    # Resize the provided slice to `new_count` elements using the provided
    # allocator.
    func resize(allocator: std::allocator, slice: []T, new_count: usize) []T {
        var cur_count: usize = countof(slice);
        var cur_size: usize = cur_count * sizeof(T);
        var new_size: usize = new_count * sizeof(T);

        var cur_pointer: *byte = *((:**byte)&slice);
        var result = allocator.reallocate(cur_pointer, alignof(T), cur_size, new_size);
        if result.is_error() {
            std::panic(result.error().*.data);
        }

        return (:[]T){(:*T)result.value(), new_count};
    }

    # Deallocate the provided slice using the provided allocator.
    func delete(allocator: std::allocator, slice: []T) void {
        var pointer: *byte = *((:**byte)&slice);
        var size: usize = countof(slice) * sizeof(T);
        allocator.deallocate(pointer, alignof(T), size);
    }
}

struct str { # namespace
    var __namespace__: any;

    # Returns true if `str` starts with `target`.
    func starts_with(str: []byte, target: []byte) bool {
        if countof(str) < countof(target) {
            return false;
        }

        for i in 0:countof(target) {
            if str[i] != target[i] {
                return false;
            }
        }

        return true;
    }

    # Returns true if `str` ends with `target`.
    func ends_with(str: []byte, target: []byte) bool {
        if countof(str) < countof(target) {
            return false;
        }

        var start = countof(str) - countof(target);
        for i in 0:countof(target) {
            if str[start+i] != target[i] {
                return false;
            }
        }

        return true;
    }

    # Returns true if `str` contains `target`.
    func contains(str: []byte, target: []byte) bool {
        if countof(str) < countof(target) {
            return false;
        }

        var start = 0u;
        for start <= (countof(str) - countof(target)) {
            var i = 0u;
            for i < countof(target) {
                if str[start+i] != target[i] {
                    break;
                }
                i = i + 1;
            }

            if i == countof(target) {
                return true;
            }
            start = start + i + 1;
        }

        return false;
    }

    func eq(lhs: []byte, rhs: []byte) bool {
        return lhs.compare(&rhs) == 0;
    }

    func ne(lhs: []byte, rhs: []byte) bool {
        return lhs.compare(&rhs) != 0;
    }

    func lt(lhs: []byte, rhs: []byte) bool {
        return lhs.compare(&rhs) < 0;
    }

    func le(lhs: []byte, rhs: []byte) bool {
        return lhs.compare(&rhs) <= 0;
    }

    func gt(lhs: []byte, rhs: []byte) bool {
        return lhs.compare(&rhs) > 0;
    }

    func ge(lhs: []byte, rhs: []byte) bool {
        return lhs.compare(&rhs) >= 0;
    }
}

struct cstr { # namespace
    var __namespace__: any;

    # Returns the number of bytes in `cstr` before the NUL terminator.
    func count(cstr: *byte) usize {
        var cur: *byte = cstr;
        for *cur != 0x00 {
            cur = (:*byte)((:usize)cur + 1u);
        }
        return (:usize)cur - (:usize)cstr;
    }

    # Returns a view of `cstr` as if it were a byte slice.
    func data(cstr: *byte) []byte {
        return (:[]byte){cstr, std::cstr::count(cstr)};
    }
}

# Strongly typed wrapper around a static byte-string providing information on
# the category of error that has occurred.
struct error_info {
    # Static byte-string describing the category of error that has occurred.
    var data: []byte;
}

# Common error type used within the Sunder standard library. The `std::error`
# type is typically used as the error template argument in `std::result`
# template instantiations. The layout of the `std::error_info` type is
# guaranteed to match the layout of the `[]byte` type, and type punning from
# `*[]byte` to `std::error` is explicitly supported.
alias error = *std::error_info;

const _ALLOCATION_FAILURE = (:std::error_info){.data = "allocation failure"};
const _BUFFER_FULL = (:std::error_info){.data = "buffer full"};
const _PARSE_FAILURE = (:std::error_info){.data = "parse failure"};
const _INVALID_ARGUMENT = (:error_info){.data = "invalid argument"};
const _RESULT_OUT_OF_RANGE = (:error_info){.data = "result out-of-range"};

struct result[[T, E]] {
    var _value: T;
    var _error: E;
    var _is_value: bool;

    func init_value(value: T) result[[T, E]] {
        return (:result[[T, E]]){
            ._value = value,
            ._error = std::zeroed[[E]](),
            ._is_value = true
        };
    }

    func init_error(error: E) result[[T, E]] {
        return (:result[[T, E]]){
            ._value = std::zeroed[[T]](),
            ._error = error,
            ._is_value = false
        };
    }

    func is_value(self: *result[[T, E]]) bool {
        return self.*._is_value;
    }

    func is_error(self: *result[[T, E]]) bool {
        return not self.*._is_value;
    }

    func value(self: *result[[T, E]]) T {
        if not self.*._is_value {
            std::panic("attempted to retrieve value from std::result in the `error` state");
        }
        return self.*._value;
    }

    func error(self: *result[[T, E]]) E {
        if self.*._is_value {
            std::panic("attempted to retrieve error from std::result in the `value` state");
        }
        return self.*._error;
    }
}

struct optional[[T]] {
    var _value: T;
    var _is_value: bool;

    func init_value(value: T) optional[[T]] {
        return (:optional[[T]]){
            ._value = value,
            ._is_value = true
        };
    }

    func init_empty() optional[[T]] {
        return (:optional[[T]]){
            ._value = std::zeroed[[T]](),
            ._is_value = false
        };
    }

    func is_value(self: *optional[[T]]) bool {
        return self.*._is_value;
    }

    func is_empty(self: *optional[[T]]) bool {
        return not self.*._is_value;
    }

    func value(self: *optional[[T]]) T {
        if not self.*._is_value {
            std::panic("attempted to retrieve value from empty std::optional");
        }
        return self.*._value;
    }
}

struct reader_itable {
    var read: func(*any, []byte) std::result[[usize, std::error]];
}

struct reader {
    var itable: *std::reader_itable;
    var object: *any;

    func init[[T]](object: *T) reader {
        const itable = (:std::reader_itable){
            .read = T::read
        };
        return (:reader){
            .itable = &itable,
            .object = object
        };
    }

    # Attempt to read `countof(buf)` bytes using the provided reader. The read
    # operation may mutate any portion of `buf`, even if less than
    # `countof(buf)` bytes are read.
    #
    # On success, this function returns the number of bytes read, which must be
    # less than or equal to `countof(buf)`, and which may be less than
    # `countof(buf)` in the event of a partial read. A successful read of size
    # zero indicates an end-of-input condition for non-zero `countof(buf)`
    # buffer sizes.
    func read(self: *reader, buf: []byte) std::result[[usize, std::error]] {
        return self.*.itable.*.read(self.*.object, buf);
    }
}

struct writer_itable {
    var write: func(*any, []byte) std::result[[usize, std::error]];
}

struct writer {
    var itable: *std::writer_itable;
    var object: *any;

    func init[[T]](object: *T) writer {
        const itable = (:std::writer_itable){
            .write = T::write
        };
        return (:writer){
            .itable = &itable,
            .object = object
        };
    }

    # Attempt to write `countof(buf)` bytes to the provided writer. The write
    # operation must not mutate the contents of `buf`.
    #
    # On success, this function returns the number of bytes written, which may
    # be less than `countof(buf)` in the event of a partial write.
    func write(self: *writer, buf: []byte) std::result[[usize, std::error]] {
        return self.*.itable.*.write(self.*.object, buf);
    }
}

struct formatter_itable {
    var format: func(*any, std::writer, []byte) std::result[[void, std::error]];
}

struct formatter {
    var itable: *std::formatter_itable;
    var object: *any;

    func init[[T]](object: *T) formatter {
        const itable = (:std::formatter_itable){
            .format = T::format
        };
        return (:formatter){
            .itable = &itable,
            .object = object
        };
    }

    # Write a formatted representation of `self` to the provided writer. The
    # format specifier `fmt` describes *how* to format `self`. Generally, each
    # type will implement its own type-specific format specifier(s). However,
    # the empty format specifier, `""`, should always be handled as a default
    # formatting case.
    func format(self: *formatter, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        return self.*.itable.*.format(self.*.object, writer, fmt);
    }
}

struct str_reader {
    var _str: []byte;
    var _idx: usize;

    func init(str: []byte) str_reader {
        return (:str_reader){
            ._str = str,
            ._idx = 0
        };
    }

    func read(self: *str_reader, buf: []byte) std::result[[usize, std::error]] {
        std::assert(self.*._idx <= countof(self.*._str));
        var cur_count = countof(self.*._str) - self.*._idx;
        var buf_count = countof(buf);
        var min_count = *std::min[[usize]](&cur_count, &buf_count);

        var dst = buf[0:min_count];
        var src = self.*._str[self.*._idx : self.*._idx + min_count];
        std::slice[[byte]]::copy(dst, src);

        self.*._idx = self.*._idx + min_count;
        return std::result[[usize, std::error]]::init_value(min_count);
    }
}

struct str_writer {
    var _str: []byte;
    var _idx: usize;

    func init(str: []byte) str_writer {
        return (:str_writer){
            ._str = str,
            ._idx = 0
        };
    }

    func write(self: *str_writer, buf: []byte) std::result[[usize, std::error]] {
        std::assert(self.*._idx <= countof(self.*._str));
        if (self.*._idx == countof(self.*._str)) {
            return std::result[[usize, std::error]]::init_error(std::error::BUFFER_FULL);
        }

        var cur_count = countof(self.*._str) - self.*._idx;
        var buf_count = countof(buf);
        var min_count = *std::min[[usize]](&cur_count, &buf_count);

        var src = buf[0:min_count];
        var dst = self.*._str[self.*._idx : self.*._idx + min_count];
        std::slice[[byte]]::copy(dst, src);

        self.*._idx = self.*._idx + min_count;
        return std::result[[usize, std::error]]::init_value(min_count);
    }
}

struct input_reader {
    func read(self: *input_reader, buf: []byte) std::result[[usize, std::error]] {
        if countof(buf) == 0 {
            return std::result[[usize, std::error]]::init_value(0);
        }

        var sysret = sys::read(sys::STDIN_FILENO, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[usize, std::error]]::init_value((:usize)sysret);
    }

    func the() *input_reader {
        const the = (:input_reader){};
        return &the;
    }
}

struct out_writer {
    func write(self: *out_writer, buf: []byte) std::result[[usize, std::error]] {
        if countof(buf) == 0 {
            return std::result[[usize, std::error]]::init_value(0);
        }

        var sysret = sys::write(sys::STDOUT_FILENO, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[usize, std::error]]::init_value((:usize)sysret);
    }

    func the() *out_writer {
        const the = (:out_writer){};
        return &the;
    }
}

struct err_writer {
    func write(self: *err_writer, buf: []byte) std::result[[usize, std::error]] {
        if countof(buf) == 0 {
            return std::result[[usize, std::error]]::init_value(0);
        }

        var sysret = sys::write(sys::STDERR_FILENO, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[usize, std::error]]::init_value((:usize)sysret);
    }

    func the() *err_writer {
        const the = (:err_writer){};
        return &the;
    }
}

# Returns the reader interface associated with the standard input stream.
func input() std::reader {
    const input = (:input_reader){};
    const input_itable = (:reader_itable){
        .read = std::input_reader::read
    };
    const input_reader = (:std::reader){
        .itable = &input_itable,
        .object = &input
    };
    return input_reader;
}

# Returns the writer interface associated with the standard output stream.
func out() std::writer {
    const out = (:out_writer){};
    const out_itable = (:writer_itable){
        .write = std::out_writer::write
    };
    const out_writer = (:std::writer){
        .itable = &out_itable,
        .object = &out
    };
    return out_writer;
}

# Returns the writer interface associated with the standard error stream.
func err() std::writer {
    const err = (:err_writer){};
    const err_itable = (:writer_itable){
        .write = std::err_writer::write
    };
    const err_writer = (:std::writer){
        .itable = &err_itable,
        .object = &err
    };
    return err_writer;
}

# Read from the provided reader, invoking the reader's `read` function
# repeatedly until either an end-of-input condition is reached or an error
# occurs.
#
# On success, this function returns a slice of bytes containing the read data,
# allocated using the provided allocator.
func read_all(reader: std::reader, allocator: std::allocator) std::result[[[]byte, std::error]] {
    var bytes = std::slice[[byte]]::new(allocator, 0);

    var buf = (:[4096]byte)[0...];
    for true {
        var result = reader.read(buf[0:countof(buf)]);
        if result.is_error() {
            std::slice[[byte]]::delete(allocator, bytes);
            return std::result[[[]byte, std::error]]::init_error(result.error());
        }

        var read_size = result.value();
        if read_size == 0 {
            break;
        }

        var cur_count = countof(bytes);
        var new_count = cur_count + read_size;
        bytes = std::slice[[byte]]::resize(allocator, bytes, new_count);
        std::slice[[byte]]::copy(bytes[cur_count:new_count], buf[0:read_size]);
    }

    return std::result[[[]byte, std::error]]::init_value(bytes);
}

# Read from the provided reader, invoking the reader's `read` function
# repeatedly until a newline is encountered, an end-of-input condition is
# reached, or an error occurs. If an end-of-input condition is encountered
# while reading a line, and the line is empty, an empty optional is returned.
# If an end-of-input condition is encountered while reading a non-empty line,
# it is treated as a newline.
#
# On success, this function returns a non-empty optional slice of bytes
# containing the read line without the ending newline, allocated using the
# provided allocator. If an end-of-input condition is encountered while reading
# an empty line, then an empty optional is returned.
#
# Example:
#   ```
#   var result = std::read_line(reader, allocator);
#   if result.is_error() {
#       # Handle the error...
#   }
#   var optional = result.value();
#   if optional.is_empty() {
#       # End-of-input was encountered. Possibly the end of a file stream, or
#       # EOF sent from a keyboard when reading standard input.
#       #
#       # Handle the empty optional...
#   }
#   defer {
#       # Queue up the allocated buffer for deletion. This defer should be
#       # omitted if the line is to be used/stored for further computation
#       # outside of the current function/block.
#       std::slice[[byte]]::delete(allocator, optional.value());
#   }
#   if countof(optional.value()) == 0 {
#       # The read line consists of a single newline character, "\n", which was
#       # trimmed away within `std::read_line`. Possibly an empty line in a
#       # text file, or a user hitting Enter/Return without typing when reading
#       # standard input.
#   }
#   ```
func read_line(reader: std::reader, allocator: std::allocator) std::result[[std::optional[[[]byte]], std::error]] {
    var bytes = std::slice[[byte]]::new(allocator, 0);

    var c = std::zeroed[[byte]]();
    for true {
        var result = reader.read((:[]byte){&c, 1});
        if result.is_error() {
            std::slice[[byte]]::delete(allocator, bytes);
            return std::result[[std::optional[[[]byte]], std::error]]::init_error(result.error());
        }

        var read_size = result.value();
        if read_size == 0 {
            if countof(bytes) == 0 {
                # End-of-input encountered while reading an empty line.
                std::slice[[byte]]::delete(allocator, bytes);
                return std::result[[std::optional[[[]byte]], std::error]]::init_value(std::optional[[[]byte]]::init_empty());
            }
            # End-of-input encountered while reading a non-empty line.
            break;
        }

        if c == '\n' {
            # End-of-line reached.
            break;
        }

        var cur_count = countof(bytes);
        var new_count = cur_count + read_size;
        bytes = std::slice[[byte]]::resize(allocator, bytes, new_count);
        std::slice[[byte]]::copy(bytes[cur_count:new_count], (:[]byte){&c, 1});
    }

    return std::result[[std::optional[[[]byte]], std::error]]::init_value(std::optional[[[]byte]]::init_value(bytes));
}

# Write `countof(buf)` bytes to the provided writer, invoking the writer's
# `write` function repeatedly until either all bytes have been written or an
# error occurs.
func write_all(writer: std::writer, buf: []byte) std::result[[void, std::error]] {
    var written: usize = 0;
    for written < countof(buf) {
        var result = writer.write(buf[written:countof(buf)]);
        if result.is_error() {
            return std::result[[void, std::error]]::init_error(result.error());
        }
        written = written + result.value();
    }
    return std::result[[void, std::error]]::init_value(void::init());
}

# Write `countof(buf)` bytes, followed by a newline, to the provided writer,
# invoking the writer's `write` function repeatedly until either all bytes have
# been written or an error occurs.
func write_line(writer: std::writer, buf: []byte) std::result[[void, std::error]] {
    var result = std::write_all(writer, buf);
    if result.is_error() {
        return std::result[[void, std::error]]::init_error(result.error());
    }

    var result = std::write_all(writer, "\n");
    if result.is_error() {
        return std::result[[void, std::error]]::init_error(result.error());
    }

    return std::result[[void, std::error]]::init_value(void::init());
}

# Write formatted bytes to the provided writer, invoking the writer's `write`
# function repeatedly until either all bytes have been written or an error
# occurs.
func write_format(writer: std::writer, format: []byte, args: []std::formatter) std::result[[void, std::error]] {
    # Current format argument index.
    var arg: usize = 0;

    # Walking along the format string accumulating bytes to be written verbatim.
    #   "some{fmt}text"
    #    ^^^^     ^^^^ Walking along either of the byte spans "some" or "text".
    const STATE_WALKING: ssize = 0;

    # Inside of a `fmt` string.
    #   "some{fmt}text"
    #         ^^^-- Walking (fmtting) along the text between the '{' '}' bytes.
    const STATE_FMTTING: ssize = 1;

    # Current state.
    var state: ssize = STATE_WALKING;

    # Start and end indices of the current state.
    var start: usize = 0;
    var end: usize = start;

    # Format message passed to `std::panic` when an invalid format string is
    # encountered. This message contains a format specifier for the `fmt` str.
    const INVALID_FORMAT_STRING_MESSAGE = "invalid format string \"{e}\"\n";

    for end < countof(format) {
        if state == STATE_WALKING {
            if format[end] != '{' and format[end] != '}' {
                # "some{fmt}text"
                #  ^^^^     ^^^^ Any non-'{' non-'}' character.
                end = end + 1;
                continue;
            }

            if (end + 1) == countof(format) {
                # "some{"
                #      ^
                # "some}"
                #      ^ End-of-format-string '{' or '}' character.
                std::panic_format(INVALID_FORMAT_STRING_MESSAGE, (:[]std::formatter)[std::formatter::init[[[]byte]](&format)]);
            }

            if format[end] == format[end + 1] {
                # "some{{text"
                #      ^^
                # "some}}text"
                #      ^^ Escaped '{' or '}' character.
                var result = std::write_all(writer, format[start:end+1]);
                if result.is_error() {
                    return result;
                }
                start = end + 2;
                end = start;
                continue;
            }

            if format[end] == '}' {
                # "some}text"
                #      ^ End-of-fmt when not in the fmt-parsing state.
                std::panic_format(
                    INVALID_FORMAT_STRING_MESSAGE,
                    (:[]std::formatter)[std::formatter::init[[[]byte]](&format)]);
            }

            # "some{fmt}text"
            #      ^ Start of format specifier.
            var result = std::write_all(writer, format[start:end]);
            if result.is_error() {
                return result;
            }
            start = end + 1;
            end = start;
            state = STATE_FMTTING;
            if arg == countof(args) {
                std::panic("invalid format argument count");
            }
            continue;
        }

        if state == STATE_FMTTING {
            if format[end] != '{' and format[end] != '}' {
                # "some{fmt}text"
                #       ^^^ Any non-'{' non-'}' character.
                end = end + 1;
                continue;
            }

            if (end + 1) < countof(format) and format[end] == format[end + 1] {
                # "some{f{{t}text"
                #        ^^
                # "some{f}}t}text"
                #        ^^ Escaped '{' or '}' character is not allowed inside
                #           a fmt string.
                std::panic_format(
                    INVALID_FORMAT_STRING_MESSAGE,
                    (:[]std::formatter)[std::formatter::init[[[]byte]](&format)]);
            }

            # "some{fmt}text"
            #          ^ End of format specifier.
            var fmt = format[start:end];
            var result = args[arg].format(writer, fmt);
            if result.is_error() {
                if result.error() == std::error::INVALID_ARGUMENT {
                    std::panic_format(
                        "invalid format specifier \"{e}\"",
                        (:[]std::formatter)[std::formatter::init[[[]byte]](&fmt)]);
                }
                return result;
            }
            start = end + 1;
            end = start;
            arg = arg + 1;
            state = STATE_WALKING;
            continue;
        }

        std::panic("unreachable");
    }

    # "some{fmt"
    #          ^ End-of-format-string reached while in the formatting state.
    if state == STATE_FMTTING {
        std::panic_format(INVALID_FORMAT_STRING_MESSAGE, (:[]std::formatter)[std::formatter::init[[[]byte]](&format)]);
    }

    # "some{fmt}text"
    #           ^^^^ Write the remaining walked text.
    var result = std::write_all(writer, format[start:end]);
    if result.is_error() {
        return result;
    }

    # Call with a format string "some {fmt} text" (N format specifiers) and N+M
    # format arguments for some non-zero M. Passing extra format arguments is a
    # hard error, but there is a specific check for this error *after* the rest
    # of the walked text has been written so that users will be able to observe
    # that an error occurred even though the full formatted string was written.
    if arg != countof(args) {
        std::panic("invalid format argument count");
    }

    return std::result[[void, std::error]]::init_value(void::init());
}

# Write `countof(buf)` bytes to the provided writer, invoking the writer's
# `write` function repeatedly until either all bytes have been written or an
# error occurs. This function panics on error.
func print(writer: std::writer, str: []byte) void {
    var result = std::write_all(writer, str);
    if result.is_error() {
        std::panic(result.error().*.data);
    }
}

# Write `countof(buf)` bytes, followed by a newline, to the provided writer,
# invoking the writer's `write` function repeatedly until all bytes have been
# written or an error occurs. This function panics on error.
func print_line(writer: std::writer, str: []byte) void {
    var result = std::write_line(writer, str);
    if result.is_error() {
        std::panic(result.error().*.data);
    }
}

# Write formatted bytes to the provided writer, invoking the writer's `write`
# function repeatedly until either all bytes have been written or an error
# occurs. This function panics on error.
func print_format(writer: std::writer, format: []byte, args: []std::formatter) void {
    var result = std::write_format(writer, format, args);
    if result.is_error() {
        std::panic(result.error().*.data);
    }
}

# Write formatted bytes, followed by a newline, to the provided writer,
# invoking the writer's `write` function repeatedly until either all bytes have
# been written or an error occurs. This function panics on error.
func print_format_line(writer: std::writer, format: []byte, args: []std::formatter) void {
    std::print_format(writer, format, args);
    std::print(writer, "\n");
}

struct iterator_itable[[T]] {
    var advance: func(*any) bool;
    var current: func(*any) T;
}

struct iterator[[T]] {
    var itable: *std::iterator_itable[[T]];
    var object: *any;

    func init[[I]](object: *I) iterator[[T]] {
        const itable = (:std::iterator_itable[[T]]){
            .advance = I::advance,
            .current = I::current
        };
        return (:iterator[[T]]){
            .itable = &itable,
            .object = object
        };
    }

    # Advance the iterator by one position. Returns true if the iterator was
    # successfully advanced. Returns false if the iterator has reached an
    # end-of-iteration condition.
    func advance(self: *iterator[[T]]) bool {
        return self.*.itable.*.advance(self.*.object);
    }

    # Returns the item at the current position of the iterator. If the backing
    # iterator has not begun iteration, or if the backing iterator has reached
    # an end-of-iteration condition, then the backing `current` function should
    # panic.
    func current(self: *iterator[[T]]) T {
        return self.*.itable.*.current(self.*.object);
    }
}

struct slice_iterator[[T]] {
    var _slice: []T;
    var _index: std::optional[[usize]];

    func init(slice: []T) slice_iterator[[T]] {
        return (:slice_iterator[[T]]){
            ._slice = slice,
            ._index = std::optional[[usize]]::init_empty()
        };
    }

    func advance(self: *slice_iterator[[T]]) bool {
        if countof(self.*._slice) == 0 {
            return false; # end-of-iteration
        }

        if self.*._index.is_empty() {
            self.*._index = std::optional[[usize]]::init_value(0);
            return true; # start-of-iteration
        }

        self.*._index = std::optional[[usize]]::init_value(self.*._index.value() + 1);
        return self.*._index.value() < countof(self.*._slice);
    }

    func current(self: *slice_iterator[[T]]) *T {
        if self.*._index.is_empty() or self.*._index.value() >= countof(self.*._slice) {
            std::panic("invalid iterator");
        }

        return &self.*._slice[self.*._index.value()];
    }
}

struct allocator_itable {
    var allocate: func(*any, usize, usize) std::result[[*byte, std::error]];
    var reallocate: func(*any, *byte, usize, usize, usize) std::result[[*byte, std::error]];
    var deallocate: func(*any, *byte, usize, usize) void;
}

struct allocator {
    var itable: *std::allocator_itable;
    var object: *any;

    func init[[T]](object: *T) allocator {
        const itable = (:std::allocator_itable){
            .allocate = T::allocate,
            .reallocate = T::reallocate,
            .deallocate = T::deallocate
        };
        return (:allocator){
            .itable = &itable,
            .object = object
        };
    }

    # Attempt to allocate a chunk of memory with the provided size and
    # alignment.
    #
    # On success, this function returns a pointer to the start of the allocated
    # chunk.
    func allocate(self: *allocator, align: usize, size: usize) std::result[[*byte, std::error]] {
        return self.*.itable.*.allocate(self.*.object, align, size);
    }

    # Reallocate a chunk of memory with the provided size and alignment,
    # starting at the address `ptr`, which was previously allocated by this
    # allocator.
    #
    # On success, this function returns a pointer to the start of the
    # reallocated block, which may have same address as the input `ptr`
    # argument in the event of a no-op reallocation.
    func reallocate(self: *allocator, ptr: *byte, align: usize, old_size: usize, new_size: usize) std::result[[*byte, std::error]] {
        return self.*.itable.*.reallocate(self.*.object, ptr, align, old_size, new_size);
    }

    # Deallocate a chunk of memory with the provided size and alignment,
    # starting at the address `ptr`, which was previously allocated by this
    # allocator.
    func deallocate(self: *allocator, ptr: *byte, align: usize, size: usize) void {
        self.*.itable.*.deallocate(self.*.object, ptr, align, size);
    }
}

# Allocate an object of type `T` using the provided allocator.
func new[[T]](allocator: std::allocator) *T {
    var result = allocator.allocate(alignof(T), sizeof(T));
    if result.is_error() {
        std::panic(result.error().*.data);
    }
    return (:*T)result.value();
}

# Deallocate the provided object of type `T` using the provided allocator.
func delete[[T]](allocator: std::allocator, object: *T) void {
    allocator.deallocate((:*byte)object, alignof(T), sizeof(T));
}

# Align the provided memory address up to the nearest the specified alignment.
func forward_align(addr: usize, align: usize) usize {
    if align == 0 {
        return addr;
    }

    # The expression:
    #   (x & (x - 1)) == 0
    # will evaluate as true for any non-zero x that is a power of two. We
    # check for an alignment of zero above, so it is safe to perform this
    # check here without the `x == 0 or ...` component that would normally
    # be required to prevent underflow.
    var align_is_power_of_two = (align & (align - 1)) == 0;
    if align_is_power_of_two {
        # Same as (addr % align) but faster as `align` is a power of two.
        var modulo = addr & (align - 1);

        # If the address is not aligned, then push the address to the next
        # value which is aligned.
        if modulo != 0 {
            addr = addr + (align - modulo);
        }

        return addr;
    }

    # Align is not a power of two. Count up until the address meets the
    # specified alignment.
    for (addr % align) != 0 {
        addr = addr + 1;
    }

    return addr;
}

# Return an object of type `T` with all bytes (including padding) zeroed.
func zeroed[[T]]() T {
    # TODO: Ensure that `object` is aligned to `alignof(T)` once alignment
    # specification is added to variable & constant declarations. The x64
    # architecture allows unaligned memory access, so this current
    # implementation is a non-issue for the Linux x64 OS/ARCH target. However,
    # this function is not necessarily portable across other architectures.
    const object: [sizeof(T)]byte = (:[sizeof(T)]byte)[0...];
    return *(:*T)&object;
}

const EXIT_SUCCESS: ssize = 0;
const EXIT_FAILURE: ssize = 1;

# Discontinue program execution.
func exit(status: ssize) void {
    sys::exit((:s32)status);
}

# Print the provided string to standard error, followed by a newline, before
# exiting with failure status. This function does not return.
func panic(why: []byte) void {
    std::panic_format("{}", (:[]std::formatter)[std::formatter::init[[[]byte]](&why)]);
}

# Print the provided formatted string to standard error, followed by a newline,
# before exiting with failure status. This function does not return.
func panic_format(format: []byte, args: []std::formatter) void {
    const PANIC_PREAMBLE = "panic: ";
    std::print(std::err(), PANIC_PREAMBLE);
    std::print_format(std::err(), format, args);
    std::print(std::err(), "\n");
    std::exit(std::EXIT_FAILURE);
}

# Panics if the provided condition does not evaluate as true.
func assert(condition: bool) void {
    if not condition {
        std::panic("assert failure");
    }
}

# Returns the two's complement wrapping result of `lhs + rhs`.
func wrapping_add[[T]](lhs: T, rhs: T) T {
    return (:T)sys::wrapping_add((:usize)lhs, (:usize)rhs);
}

# Returns the two's complement wrapping result of `lhs - rhs`.
func wrapping_sub[[T]](lhs: T, rhs: T) T {
    return (:T)sys::wrapping_sub((:usize)lhs, (:usize)rhs);
}

# Returns the two's complement wrapping result of `lhs * rhs`.
func wrapping_mul[[T]](lhs: T, rhs: T) T {
    return (:T)sys::wrapping_mul((:usize)lhs, (:usize)rhs);
}

# Returns a signed integer less than, equal to, or greater than zero if `lhs`
# is found, respectively, to be less than, equal to, or greater than `rhs`.
func compare[[T]](lhs: *T, rhs: *T) ssize {
    return T::compare(lhs, rhs);
}

# Returns true if `lhs` is found to be equal to `rhs`.
func eq[[T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) == 0;
}

# Returns true if `lhs` is found to be equal to `rhs`.
func ne[[T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) != 0;
}

# Returns true if `lhs` is found to be less than `rhs`.
func lt[[T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) < 0;
}

# Returns true if `lhs` is found to be less than or equal to `rhs`.
func le[[T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) <= 0;
}

# Returns true if `lhs` is found to be greater than `rhs`.
func gt[[T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) > 0;
}

# Returns true if `lhs` is found to be greater than or equal to `rhs`.
func ge[[T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) >= 0;
}

# Returns the minimum value of `x` and `y`.
func min[[T]](x: *T, y: *T) *T {
    if std::lt[[T]](x, y) {
        return x;
    }
    return y;
}

# Returns the maximum value of `x` and `y`.
func max[[T]](x: *T, y: *T) *T {
    if std::gt[[T]](x, y) {
        return x;
    }
    return y;
}

# Key-value pair used in map operations.
struct key_value_pair[[K, V]] {
    var key: K;
    var value: V;
}

# View of a key object and value object conceptually belonging to a key-value
# pair, even if the key object and value object are stored separately. Used in
# map operations.
struct key_value_view[[K, V]] {
    var key: *K;
    var value: *V;
}

extend void func init() void { }

extend integer func _init_umax_from_str(str: []byte, radix: usize) std::result[[std::umax, std::error]] {
    if radix != 0 and radix != 2 and radix != 8 and radix != 10 and radix != 16 {
        return std::result[[umax, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    var cur: usize = 0;
    var end: usize = countof(str);

    # Parse optional + sign.
    if (end - cur) > countof("+") and str[cur] == '+' {
        cur = cur + 1;
    }

    # Parse radix.
    if radix == 0 {
        var is_bin = (end - cur) >= countof("0b") and str[cur] == '0' and str[cur+1] == 'b';
        var is_oct = (end - cur) >= countof("0o") and str[cur] == '0' and str[cur+1] == 'o';
        var is_hex = (end - cur) >= countof("0x") and str[cur] == '0' and str[cur+1] == 'x';

        if is_bin {
            radix = 2;
            cur = cur + countof("0b");
        }
        elif is_oct {
            radix = 8;
            cur = cur + countof("0o");
        }
        elif is_hex {
            radix = 16;
            cur = cur + countof("0x");
        }
        else {
            radix = 10;
        }
    }

    # Parse digits.
    if cur == end {
        return std::result[[std::umax, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    var accum: std::umax = 0;
    for cur != end {
        var c = str[cur];
        cur = cur + 1;

        var digit: std::umax = 0;
        if '0' <= c and c <= '9' {
            digit = (:std::umax)c - '0';
        }
        elif 'A' <= c and c <= 'F' {
            digit = (:std::umax)c - 'A' + 0xA;
        }
        elif 'a' <= c and c <= 'f' {
            digit = (:std::umax)c - 'a' + 0xA;
        }
        else {
            return std::result[[std::umax, std::error]]::init_error(std::error::PARSE_FAILURE);
        }

        if (:usize)digit >= radix {
            return std::result[[std::umax, std::error]]::init_error(std::error::PARSE_FAILURE);
        }

        if accum != 0 and std::umax::MAX / accum < (:typeof(accum))radix {
            return std::result[[std::umax, std::error]]::init_error(std::error::RESULT_OUT_OF_RANGE);
        }
        accum = accum * (:typeof(accum))radix;

        if std::umax::MAX - accum < (:typeof(accum))digit {
            return std::result[[std::umax, std::error]]::init_error(std::error::RESULT_OUT_OF_RANGE);
        }
        accum = accum + (:typeof(accum))digit;
    }

    return std::result[[std::umax, std::error]]::init_value(accum);
}

extend integer func _init_smax_from_str(str: []byte, radix: usize) std::result[[std::smax, std::error]] {
    var sign = +1s;
    if countof(str) != 0 and str[0] == '-' {
        sign = -1s;
        str = str[1:countof(str)];
    }

    var result = integer::_init_umax_from_str(str, radix);
    if result.is_error() {
        return std::result[[std::smax, std::error]]::init_error(result.error());
    }

    var magnitude = result.value();
    var is_out_of_range =
        sign == +1 and magnitude > (:std::umax)std::smax::MAX or
        sign == -1 and magnitude > (:std::umax)std::smax::MAX + 1;
    if is_out_of_range {
        return std::result[[std::smax, std::error]]::init_error(std::error::RESULT_OUT_OF_RANGE);
    }

    if sign == -1 {
        # Special case for the minimum value of a two's complement signed
        # integer which will produce an integer out-of-range error when
        # multiplied by negative one.
        if magnitude == (:std::umax)std::smax::MAX + 1 {
            return std::result[[std::smax, std::error]]::init_value(std::smax::MIN);
        }

        var value = (:std::smax)-1s * (:std::smax)magnitude;
        return std::result[[std::smax, std::error]]::init_value(value);
    }

    return std::result[[std::smax, std::error]]::init_value((:std::smax)result.value());
}

extend integer func _init_uint_from_str[[T]](str: []byte, radix: usize) std::result[[T, std::error]] {
    var result = integer::_init_umax_from_str(str, radix);
    if result.is_error() {
        return std::result[[T, std::error]]::init_error(result.error());
    }
    if result.value() > (:std::umax)T::MAX {
        return std::result[[T, std::error]]::init_error(std::error::RESULT_OUT_OF_RANGE);
    }
    return std::result[[T, std::error]]::init_value((:T)result.value());
}

extend integer func _init_sint_from_str[[T]](str: []byte, radix: usize) std::result[[T, std::error]] {
    var result = integer::_init_smax_from_str(str, radix);
    if result.is_error() {
        return std::result[[T, std::error]]::init_error(result.error());
    }
    if result.value() < (:std::smax)T::MIN or result.value() > (:std::smax)T::MAX {
        return std::result[[T, std::error]]::init_error(std::error::RESULT_OUT_OF_RANGE);
    }
    return std::result[[T, std::error]]::init_value((:T)result.value());
}

extend integer func _compare[[T]](lhs: T, rhs: T) ssize {
    if lhs < rhs { return -1; }
    if lhs > rhs { return +1; }
    return 0;
}

# Accepted format language:
#   [#][radix]
#
# Use of "#" indicates that the alternate form of the integer should be
# formatted. Integers formatted in decimal are unchanged. Integers formatted in
# binary are prefixed with "0b". Integers formatted in octal are prefixed with
# "0o". And integers formatted in hexadecimal are prefixed with "0x".
#
# Accepted strings for radix:
#   ""  => decimal (default)
#   "d" => decimal
#   "b" => binary
#   "o" => octal
#   "x" => hexadecimal (lower)
#   "X" => hexadecimal (upper)
extend integer func _format_umax(int: std::umax, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    const DIGITS_TABLE_COUNT: usize = 16;
    const DIGITS_TABLE_LOWER = (:[DIGITS_TABLE_COUNT]byte)[
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    ];
    const DIGITS_TABLE_UPPER = (:[DIGITS_TABLE_COUNT]byte)[
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
    ];

    var fmt_idx = 0u;

    var is_digits_prefix = false;
    if fmt_idx < countof(fmt) and fmt[fmt_idx] == '#' {
        is_digits_prefix = true;
        fmt_idx = fmt_idx + 1;
    }

    var radix: usize = 10;
    var digits_prefix: []byte = "";
    var digits_table: []byte = DIGITS_TABLE_LOWER[0:DIGITS_TABLE_COUNT];

    if fmt_idx < countof(fmt) {
        var c: byte = fmt[fmt_idx];
        fmt_idx = fmt_idx + 1;

        if c == 'd' {
            # Decimal defaults already set.
        }
        elif c == 'b' {
            radix = 2;
            digits_prefix = "0b";
        }
        elif c == 'o' {
            radix = 8;
            digits_prefix = "0o";
        }
        elif c == 'x' {
            radix = 16;
            digits_prefix = "0x";
        }
        elif c == 'X' {
            radix = 16;
            digits_prefix = "0x";
            digits_table = DIGITS_TABLE_UPPER[0:DIGITS_TABLE_COUNT];
        }
        else {
            return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }
    }

    if fmt_idx != countof(fmt) {
        return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
    }

    const OUTPUT_COUNT: usize = countof("0b") + sizeof(usize) * 8;
    var output = (:[OUTPUT_COUNT]byte)[0...];
    var output_index: usize = countof(output) - 1;

    if int == 0 {
        # Write a single zero digit.
        output[output_index] = '0';
        output_index = output_index - 1;
    }
    for int != 0 {
        var div: std::umax = int / (:std::umax)radix;
        var rem: std::umax = int - (:std::umax)radix * (int / (:std::umax)radix);

        var digit: byte = digits_table[(:usize)rem];
        output[output_index] = digit;
        output_index = output_index - 1;

        int = div;
    }

    if is_digits_prefix and countof(digits_prefix) != 0 {
        for i in countof(digits_prefix) {
            output[output_index] = digits_prefix[countof(digits_prefix) - i - 1];
            output_index = output_index - 1;
        }
    }

    return std::write_all(writer, output[output_index+1:countof(output)]);
}

# Accepted format language:
#   [#][radix]
#
# Use of "#" indicates that the alternate form of the integer should be
# formatted. Integers formatted in decimal are unchanged. Integers formatted in
# binary are prefixed with "0b". Integers formatted in octal are prefixed with
# "0o". And integers formatted in hexadecimal are prefixed with "0x".
#
# Accepted strings for radix:
#   ""  => decimal (default)
#   "d" => decimal
#   "b" => binary
#   "o" => octal
#   "x" => hexadecimal (lower)
#   "X" => hexadecimal (upper)
extend integer func _format_smax(int: std::smax, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    if int < 0 {
        var result = std::write_all(writer, "-");
        if result.is_error() {
            return result;
        }
    }

    var magnitude: std::umax = 0;
    if int >= 0 {
        # Absolute value of a non-negative integer is itself.
        magnitude = (:std::umax)int;
    }
    elif int == std::smax::MIN {
        # Special case for the minimum value of a two's complement signed
        # integer, which will produce an integer out-of-range error when
        # multiplied by negative one, as the negated (positive) value is
        # un-representable as a two's complement ssize.
        magnitude = (:std::umax)std::smax::MAX + 1;
    }
    else {
        magnitude = (:std::umax)((:std::smax)-1s * int);
    }

    return integer::_format_umax(magnitude, writer, fmt);
}

extend byte const MIN: byte = 0x00;
extend byte const MAX: byte = 0xFF;
extend byte const BITS: usize = 8;
extend byte func compare(lhs: *byte, rhs: *byte) ssize {
    return integer::_compare[[std::umax]]((:std::umax)*lhs, (:std::umax)*rhs);
}
extend byte func hash(self: *byte) usize {
    return (:usize)*self;
}

extend u8 const MIN: u8 = 0x00;
extend u8 const MAX: u8 = 0xFF;
extend u8 func init_from_str(str: []byte, radix: usize) std::result[[u8, std::error]] {
    return integer::_init_uint_from_str[[u8]](str, radix);
}
extend u8 func compare(lhs: *u8, rhs: *u8) ssize {
    return integer::_compare[[std::umax]]((:std::umax)*lhs, (:std::umax)*rhs);
}
extend u8 func hash(self: *u8) usize {
    return (:usize)*self;
}
extend u8 func format(self: *u8, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_umax((:std::umax)*self, writer, fmt);
}

extend u16 const MIN: u16 = 0x0000;
extend u16 const MAX: u16 = 0xFFFF;
extend u16 func init_from_str(str: []byte, radix: usize) std::result[[u16, std::error]] {
    return integer::_init_uint_from_str[[u16]](str, radix);
}
extend u16 func compare(lhs: *u16, rhs: *u16) ssize {
    return integer::_compare[[std::umax]]((:std::umax)*lhs, (:std::umax)*rhs);
}
extend u16 func hash(self: *u16) usize {
    return (:usize)*self;
}
extend u16 func format(self: *u16, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_umax((:std::umax)*self, writer, fmt);
}

extend u32 const MIN: u32 = 0x00000000;
extend u32 const MAX: u32 = 0xFFFFFFFF;
extend u32 func init_from_str(str: []byte, radix: usize) std::result[[u32, std::error]] {
    return integer::_init_uint_from_str[[u32]](str, radix);
}
extend u32 func compare(lhs: *u32, rhs: *u32) ssize {
    return integer::_compare[[std::umax]]((:std::umax)*lhs, (:std::umax)*rhs);
}
extend u32 func hash(self: *u32) usize {
    return (:usize)*self;
}
extend u32 func format(self: *u32, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_umax((:std::umax)*self, writer, fmt);
}

extend u64 const MIN: u64 = 0x0000000000000000;
extend u64 const MAX: u64 = 0xFFFFFFFFFFFFFFFF;
extend u64 func init_from_str(str: []byte, radix: usize) std::result[[u64, std::error]] {
    return integer::_init_uint_from_str[[u64]](str, radix);
}
extend u64 func compare(lhs: *u64, rhs: *u64) ssize {
    return integer::_compare[[std::umax]]((:std::umax)*lhs, (:std::umax)*rhs);
}
extend u64 func hash(self: *u64) usize {
    return (:usize)*self;
}
extend u64 func format(self: *u64, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_umax((:std::umax)*self, writer, fmt);
}

extend usize const MIN: usize = (:usize)u64::MIN;
extend usize const MAX: usize = (:usize)u64::MAX;
extend usize func init_from_str(str: []byte, radix: usize) std::result[[usize, std::error]] {
    return integer::_init_uint_from_str[[usize]](str, radix);
}
extend usize func compare(lhs: *usize, rhs: *usize) ssize {
    return integer::_compare[[std::umax]]((:std::umax)*lhs, (:std::umax)*rhs);
}
extend usize func hash(self: *usize) usize {
    return *self;
}
extend usize func format(self: *usize, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_umax((:std::umax)*self, writer, fmt);
}

extend s8 const MIN: s8 = (:s8)0x80u8;
extend s8 const MAX: s8 = (:s8)0x7Fu8;
extend s8 func init_from_str(str: []byte, radix: usize) std::result[[s8, std::error]] {
    return integer::_init_sint_from_str[[s8]](str, radix);
}
extend s8 func compare(lhs: *s8, rhs: *s8) ssize {
    return integer::_compare[[std::smax]]((:std::smax)*lhs, (:std::smax)*rhs);
}
extend s8 func hash(self: *s8) usize {
    return (:usize)*self;
}
extend s8 func format(self: *s8, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_smax((:std::smax)*self, writer, fmt);
}

extend s16 const MIN: s16 = (:s16)0x8000u16;
extend s16 const MAX: s16 = (:s16)0x7FFFu16;
extend s16 func init_from_str(str: []byte, radix: usize) std::result[[s16, std::error]] {
    return integer::_init_sint_from_str[[s16]](str, radix);
}
extend s16 func compare(lhs: *s16, rhs: *s16) ssize {
    return integer::_compare[[std::smax]]((:std::smax)*lhs, (:std::smax)*rhs);
}
extend s16 func hash(self: *s16) usize {
    return (:usize)*self;
}
extend s16 func format(self: *s16, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_smax((:std::smax)*self, writer, fmt);
}

extend s32 const MIN: s32 = (:s32)0x80000000u32;
extend s32 const MAX: s32 = (:s32)0x7FFFFFFFu32;
extend s32 func init_from_str(str: []byte, radix: usize) std::result[[s32, std::error]] {
    return integer::_init_sint_from_str[[s32]](str, radix);
}
extend s32 func compare(lhs: *s32, rhs: *s32) ssize {
    return integer::_compare[[std::smax]]((:std::smax)*lhs, (:std::smax)*rhs);
}
extend s32 func hash(self: *s32) usize {
    return (:usize)*self;
}
extend s32 func format(self: *s32, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_smax((:std::smax)*self, writer, fmt);
}

extend s64 const MIN: s64 = (:s64)0x8000000000000000u64;
extend s64 const MAX: s64 = (:s64)0x7FFFFFFFFFFFFFFFu64;
extend s64 func init_from_str(str: []byte, radix: usize) std::result[[s64, std::error]] {
    return integer::_init_sint_from_str[[s64]](str, radix);
}
extend s64 func compare(lhs: *s64, rhs: *s64) ssize {
    return integer::_compare[[std::smax]]((:std::smax)*lhs, (:std::smax)*rhs);
}
extend s64 func hash(self: *s64) usize {
    return (:usize)*self;
}
extend s64 func format(self: *s64, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_smax((:std::smax)*self, writer, fmt);
}

extend ssize const MIN: ssize = (:ssize)s64::MIN;
extend ssize const MAX: ssize = (:ssize)s64::MAX;
extend ssize func init_from_str(str: []byte, radix: usize) std::result[[ssize, std::error]] {
    return integer::_init_sint_from_str[[ssize]](str, radix);
}
extend ssize func compare(lhs: *ssize, rhs: *ssize) ssize {
    return integer::_compare[[std::smax]]((:std::smax)*lhs, (:std::smax)*rhs);
}
extend ssize func hash(self: *ssize) usize {
    return (:usize)*self;
}
extend ssize func format(self: *ssize, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    return integer::_format_smax((:std::smax)*self, writer, fmt);
}

extend []byte func compare(lhs: *[]byte, rhs: *[]byte) ssize {
    var lhs_data = *lhs;
    var rhs_data = *rhs;
    var lhs_count = countof(lhs_data);
    var rhs_count = countof(rhs_data);
    var count = *std::min[[usize]](&lhs_count, &rhs_count);
    for i in count {
        if lhs_data[i] != rhs_data[i] {
            return (:ssize)lhs_data[i] - (:ssize)rhs_data[i];
        }
    }
    return (:ssize)countof(lhs_data) - (:ssize)countof(rhs_data);
}

extend []byte func hash(self: *[]byte) usize {
    # Implementation of djb2 with an additional statement that zeroes the upper
    # five bits of the hash before the multiplication in order to prevent
    # overflow.
    var hash = 5381u;
    for i in countof(*self) {
        const MASK = 0b11111u << ((sizeof(usize) * byte::BITS) - 5);
        hash = (hash & MASK) * 33 + (:usize)self.*[i];
    }
    return hash;
}

# Accepted format specifiers:
#   ""  => verbatim (default)
#   "e" => escaped (e.g. "\0\t\n\'\"\xFFabc)
extend []byte func format(self: *[]byte, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
    # Format specifier: ""
    if countof(fmt) == 0 {
        return std::write_all(writer, *self);
    }

    # Format specifier: "e"
    if countof(fmt) == 1 and fmt[0] == 'e' {
        for i in countof(*self) {
            var c: byte = self.*[i];
            if c == '\0' {
                var result = std::write_all(writer, "\\0");
                if result.is_error() {
                    return result;
                }
                continue;
            }
            if c == '\t' {
                var result = std::write_all(writer, "\\t");
                if result.is_error() {
                    return result;
                }
                continue;
            }
            if c == '\n' {
                var result = std::write_all(writer, "\\n");
                if result.is_error() {
                    return result;
                }
                continue;
            }
            if c == '\'' {
                var result = std::write_all(writer, "\\\'");
                if result.is_error() {
                    return result;
                }
                continue;
            }
            if c == '\"' {
                var result = std::write_all(writer, "\\\"");
                if result.is_error() {
                    return result;
                }
                continue;
            }
            if c == '\\' {
                var result = std::write_all(writer, "\\\\");
                if result.is_error() {
                    return result;
                }
                continue;
            }
            if c < ' ' or c > '~' {
                const DIGITS = (:[]byte)[
                    '0', '1', '2', '3', '4', '5', '6', '7',
                    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
                ];
                var hex = (:[]byte)[
                    DIGITS[(:usize)c & 0xF0 >> 4],
                    DIGITS[(:usize)c & 0x0F]
                ];
                var result = std::write_format(
                    writer,
                    "\\x{}",
                    (:[]std::formatter)[
                        std::formatter::init[[[]byte]](&hex)]);
                if result.is_error() {
                    return result;
                }
                continue;
            }
            var result = std::write_all(writer, (:[]byte){&c, 1});
            if result.is_error() {
                return result;
            }
        }
        return std::result[[void, std::error]]::init_value(void::init());
    }

    return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
}

extend error const ALLOCATION_FAILURE = &std::_ALLOCATION_FAILURE;
extend error const BUFFER_FULL = &std::_BUFFER_FULL;
extend error const PARSE_FAILURE = &std::_PARSE_FAILURE;
extend error const INVALID_ARGUMENT = &std::_INVALID_ARGUMENT;
extend error const RESULT_OUT_OF_RANGE = &std::_RESULT_OUT_OF_RANGE;
