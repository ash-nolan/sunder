namespace std;
import "sys";

struct result[[:T, :E]] {
    var _value: T;
    var _error: E;
    var _is_value: bool;

    func init_value(value: T) result[[:T, :E]] {
        return (:result[[:T, :E]]){
            ._value = value,
            ._error = std::zeroed[[:E]](),
            ._is_value = true
        };
    }

    func init_error(error: E) result[[:T, :E]] {
        return (:result[[:T, :E]]){
            ._value = std::zeroed[[:T]](),
            ._error = error,
            ._is_value = false
        };
    }

    func is_value(self: *result[[:T, :E]]) bool {
        return self.*._is_value;
    }

    func is_error(self: *result[[:T, :E]]) bool {
        return not self.*._is_value;
    }

    func value(self: *result[[:T, :E]]) T {
        if not self.*._is_value {
            std::panic("attempted to retrieve value from std::result in the `error` state");
        }
        return self.*._value;
    }

    func error(self: *result[[:T, :E]]) E {
        if self.*._is_value {
            std::panic("attempted to retrieve error from std::result in the `value` state");
        }
        return self.*._error;
    }
}

struct optional[[:T]] {
    var _value: T;
    var _is_value: bool;

    func init_value(value: T) optional[[:T]] {
        return (:optional[[:T]]){
            ._value = value,
            ._is_value = true
        };
    }

    func init_empty() optional[[:T]] {
        return (:optional[[:T]]){
            ._value = std::zeroed[[:T]](),
            ._is_value = false
        };
    }

    func is_value(self: *optional[[:T]]) bool {
        return self.*._is_value;
    }

    func is_empty(self: *optional[[:T]]) bool {
        return not self.*._is_value;
    }

    func value(self: *optional[[:T]]) T {
        if not self.*._is_value {
            std::panic("attempted to retrieve value from empty std::optional");
        }
        return self.*._value;
    }
}

struct reader_itable {
    var read: func(*any, []byte) std::result[[:usize, :[]byte]];
}

struct reader {
    var itable: *std::reader_itable;
    var object: *any;

    func init[[:T]](object: *T) std::reader {
        const itable = (:std::reader_itable){
            .read = T::read
        };
        return (:std::reader){
            .itable = &itable,
            .object = object
        };
    }

    # Attempt to read `countof(buf)` bytes using the provided reader. The read
    # operation may mutate any portion of `buf`, even if less than
    # `countof(buf)` bytes are read.
    #
    # On success, this function returns the number of bytes read, which must be
    # less than or equal to `countof(buf)`, and which may be less than
    # `countof(buf)` in the event of a partial read. A successful read of size
    # zero indicates an end-of-input condition for non-zero `countof(buf)`
    # buffer sizes.
    #
    # On failure, this function returns a static string describing the failure.
    func read(self: *reader, buf: []byte) std::result[[:usize, :[]byte]] {
        return self.*.itable.*.read(self.*.object, buf);
    }
}

struct writer_itable {
    var write: func(*any, []byte) std::result[[:usize, :[]byte]];
}

struct writer {
    var itable: *std::writer_itable;
    var object: *any;

    func init[[:T]](object: *T) std::writer {
        const itable = (:std::writer_itable){
            .write = T::write
        };
        return (:std::writer){
            .itable = &itable,
            .object = object
        };
    }

    # Attempt to write `countof(buf)` bytes using the provided writer. The
    # write operation must not mutate the contents of `buf`.
    #
    # On success, this function returns the number of bytes written, which may
    # be less than `countof(buf)` in the event of a partial write.
    #
    # On failure, this function returns a static string describing the failure.
    func write(self: *writer, buf: []byte) std::result[[:usize, :[]byte]] {
        return self.*.itable.*.write(self.*.object, buf);
    }
}

struct formatter_itable {
    var format: func(*any, std::writer, []byte) std::result[[:usize, :[]byte]];
}

struct formatter {
    var itable: *std::formatter_itable;
    var object: *any;

    func init[[:T]](object: *T) std::formatter {
        const itable = (:std::formatter_itable){
            .format = T::format
        };
        return (:std::formatter){
            .itable = &itable,
            .object = object
        };
    }

    # Write a formatted representation of `self` to the provided writer. The
    # format specifier `fmt` describes *how* to format `self`. Generally, each
    # type will implement its own type-specific format specifier(s). However,
    # the empty format specifier, `""`, should always be handled as a default
    # formatting case.
    #
    # On success, this function returns the number of bytes written to the
    # provided writer. Types implementing this function should ensure that all
    # bytes are written to the provided writer.
    #
    # On failure, this function returns a static string describing the failure.
    # In the event of a write error, the erroneous write result should be
    # returned. If the provided format specifier does not match a format
    # specifier implemented by the type, then the format function should call
    #
    #   std::formatter::invalid_format_specifier(fmt);
    #
    # which will terminate the program with failure status.
    func format(self: *formatter, writer: std::writer, fmt: []byte) std::result[[:usize, :[]byte]] {
        return self.*.itable.*.format(self.*.object, writer, fmt);
    }

    func invalid_format_string(format: []byte) void {
        var str = std::str::init(format);
        std::panic_format(
            "invalid format string \"{e}\"\n",
            (:[]std::formatter)[std::formatter::init[[:std::str]](&str)]);
    }

    func invalid_format_specifier(fmt: []byte) void {
        var str = std::str::init(fmt);
        std::panic_format(
            "invalid format specifier \"{e}\"\n",
            (:[]std::formatter)[std::formatter::init[[:std::str]](&str)]);
    }
}

struct allocator_itable {
    var allocate: func(*any, usize, usize) std::result[[:*byte, :[]byte]];
    var reallocate: func(*any, *byte, usize, usize, usize) std::result[[:*byte, :[]byte]];
    var deallocate: func(*any, *byte, usize, usize) void;
}

struct allocator {
    const ERROR_INVALID_POINTER = "invalid pointer";
    const ERROR_INVALID_ALIGNMENT = "invalid alignment";
    const ERROR_INVALID_SIZE = "invalid size";

    var itable: *std::allocator_itable;
    var object: *any;

    func init[[:T]](object: *T) std::allocator {
        const itable = (:std::allocator_itable){
            .allocate = T::allocate,
            .reallocate = T::reallocate,
            .deallocate = T::deallocate
        };
        return (:std::allocator){
            .itable = &itable,
            .object = object
        };
    }

    # Attempt to allocate a chunk of memory with the provided size and
    # alignment.
    #
    # On success, this function returns a pointer to the start of the allocated
    # chunk.
    #
    # On failure, this function returns a static string describing the failure.
    func allocate(self: *allocator, align: usize, size: usize) std::result[[:*byte, :[]byte]] {
        return self.*.itable.*.allocate(self.*.object, align, size);
    }

    # Reallocate a chunk of memory with the provided size and alignment,
    # starting at the address `ptr`, which was previously allocated by this
    # allocator.
    #
    # On success, this function returns a pointer to the start of the
    # reallocated block, which may have same address as the input `ptr` argument
    # in the event of a no-op reallocation.
    #
    # On failure, this function returns a static string describing the failure.
    func reallocate(self: *allocator, ptr: *byte, align: usize, old_size: usize, new_size: usize) std::result[[:*byte, :[]byte]] {
        return self.*.itable.*.reallocate(self.*.object, ptr, align, old_size, new_size);
    }

    # Deallocate a chunk of memory with the provided size and alignment,
    # starting at the address `ptr`, which was previously allocated by this
    # allocator.
    func deallocate(self: *allocator, ptr: *byte, align: usize, size: usize) void {
        self.*.itable.*.deallocate(self.*.object, ptr, align, size);
    }
}

struct int[[:T]] {
    var value: T;

    func init(value: T) int[[:T]] {
        return (:int[[:T]]){.value = value};
    }

    func parse_from_bytes(bytes: []byte, radix: usize) std::result[[:std::int[[:T]], :[]byte]] {
        if radix != 0 and (radix < 2 or radix > 36) {
            return std::result[[:std::int[[:T]], :[]byte]]::init_error("invalid radix");
        }

        var cur: usize = 0;
        var end: usize = countof(bytes);

        # Parse optional sign (+ or -).
        var sign: ssize = +1;
        if (end - cur) > countof("+") and bytes[cur] == '+' {
            sign = +1;
            cur = cur + 1;
        }
        if (end - cur) > countof("-") and bytes[cur] == '-' {
            sign = -1;
            cur = cur + 1;
        }

        # Parse radix.
        if radix == 0 {
            var is_bin = (end - cur) >= countof("0b") and bytes[cur] == '0' and bytes[cur+1] == 'b';
            var is_oct = (end - cur) >= countof("0o") and bytes[cur] == '0' and bytes[cur+1] == 'o';
            var is_hex = (end - cur) >= countof("0x") and bytes[cur] == '0' and bytes[cur+1] == 'x';

            if is_bin {
                radix = 2;
                cur = cur + countof("0b");
            }
            elif is_oct {
                radix = 8;
                cur = cur + countof("0o");
            }
            elif is_hex {
                radix = 16;
                cur = cur + countof("0x");
            }
            else {
                radix = 10;
            }
        }

        # Parse digits.
        if cur == end {
            return std::result[[:std::int[[:T]], :[]byte]]::init_error("integer contains no digits");
        }
        var accum: u64 = 0; # Digit accumulator (`u64` acting as `uintmax_t`).
        var ACCUM_MAX: u64 = 0xFFFFFFFFFFFFFFFF;
        for cur != end {
            var c = bytes[cur];
            cur = cur + 1;

            var digit: usize = 0;
            if '0' <= c and c <= '9' {
                digit = (:usize)c - '0';
            }
            elif 'A' <= c and c <= 'F' {
                digit = (:usize)c - 'A' + 0xA;
            }
            elif 'a' <= c and c <= 'f' {
                digit = (:usize)c - 'a' + 0xA;
            }
            else {
                return std::result[[:std::int[[:T]], :[]byte]]::init_error("integer contains invalid digit");
            }

            if digit >= radix {
                return std::result[[:std::int[[:T]], :[]byte]]::init_error("integer contains invalid digit");
            }

            if accum != 0 and ACCUM_MAX / accum < (:typeof(accum))radix {
                return std::result[[:std::int[[:T]], :[]byte]]::init_error("integer out-of-range");
            }
            accum = accum * (:typeof(accum))radix;

            if ACCUM_MAX - accum < (:typeof(accum))digit {
                return std::result[[:std::int[[:T]], :[]byte]]::init_error("integer out-of-range");
            }
            accum = accum + (:typeof(accum))digit;
        }

        const IS_UINT = (:T)-1s > 0;
        const IS_SINT = (:T)-1s < 0;
        var is_out_of_range =
            IS_UINT and sizeof(:T) == sizeof(:u8)  and accum > 0xFF or
            IS_UINT and sizeof(:T) == sizeof(:u16) and accum > 0xFFFF or
            IS_UINT and sizeof(:T) == sizeof(:u32) and accum > 0xFFFFFFFF or
            IS_UINT and sizeof(:T) == sizeof(:u64) and accum > 0xFFFFFFFFFFFFFFFF or
            IS_SINT and sizeof(:T) == sizeof(:s8)  and sign == +1 and accum > 0x7F or
            IS_SINT and sizeof(:T) == sizeof(:s16) and sign == +1 and accum > 0x7FFF or
            IS_SINT and sizeof(:T) == sizeof(:s32) and sign == +1 and accum > 0x7FFFFFFF or
            IS_SINT and sizeof(:T) == sizeof(:s64) and sign == +1 and accum > 0x7FFFFFFFFFFFFFFF or
            IS_SINT and sizeof(:T) == sizeof(:s8)  and sign == -1 and accum > 0x80 or
            IS_SINT and sizeof(:T) == sizeof(:s16) and sign == -1 and accum > 0x8000 or
            IS_SINT and sizeof(:T) == sizeof(:s32) and sign == -1 and accum > 0x80000000 or
            IS_SINT and sizeof(:T) == sizeof(:s64) and sign == -1 and accum > 0x8000000000000000;
        if IS_UINT and sign == -1 or is_out_of_range {
            return std::result[[:std::int[[:T]], :[]byte]]::init_error("integer out-of-range");
        }

        var value: T = (:T)accum;
        if sign == -1 {
            value = value * (:T)-1s;
        }

        return std::result[[:std::int[[:T]], :[]byte]]::init_value(std::int[[:T]]::init(value));
    }

    func compare(lhs: *int[[:T]], rhs: *int[[:T]]) ssize {
        if lhs.*.value < rhs.*.value {
            return -1;
        }
        if lhs.*.value > rhs.*.value {
            return +1;
        }
        return 0;
    }

    # Accepted format specifiers:
    #   ""  => decimal (default)
    #   "d" => decimal
    #   "b" => binary
    #   "o" => octal
    #   "x" => hexadecimal (lower)
    #   "X" => hexadecimal (upper)
    func format(
        self: *std::int[[:T]],
        writer: std::writer,
        fmt: []byte
    ) std::result[[:usize, :[]byte]] {
        # All non-default format specifiers have a length of one byte.
        if countof(fmt) > 1 {
            std::formatter::invalid_format_specifier(fmt);
        }

        const DIGITS_TABLE_COUNT: usize = 16;
        const DIGITS_TABLE_LOWER = (:[DIGITS_TABLE_COUNT]byte)[
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        const DIGITS_TABLE_UPPER = (:[DIGITS_TABLE_COUNT]byte)[
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];

        var radix: T = 10;
        var digits_prefix: []byte = "";
        var digits_table: []byte = DIGITS_TABLE_LOWER[0:DIGITS_TABLE_COUNT];

        if countof(fmt) != 0 {
            var c: byte = fmt[0];
            if c == 'd' {
                # Decimal defaults already set.
            }
            elif c == 'b' {
                radix = 2;
                digits_prefix = "0b";
            }
            elif c == 'o' {
                radix = 8;
                digits_prefix = "0o";
            }
            elif c == 'x' {
                radix = 16;
                digits_prefix = "0x";
            }
            elif c == 'X' {
                radix = 16;
                digits_prefix = "0x";
                digits_table = DIGITS_TABLE_UPPER[0:DIGITS_TABLE_COUNT];
            }
            else {
                std::formatter::invalid_format_specifier(fmt);
            }
        }

        var value: T = self.*.value;

        var is_negative: bool = value < 0;
        if is_negative {
            value = value * (:T)-1s;
        }

        # More than enough bytes to store the sign and digits of any number with
        # a size less than or equal to 64 bits.
        const OUTPUT_COUNT: usize = countof("-0b") + 64;
        var output = (:[OUTPUT_COUNT]byte)[0...];
        var output_index: usize = countof(output) - 1;

        if value == 0 {
            # Write a single zero digit.
            output[output_index] = '0';
            output_index = output_index - 1;
        }
        for value != 0 {
            var div: T = value / radix;
            var rem: T = value - radix * (value / radix);

            var digit: byte = digits_table[(:usize)rem];
            output[output_index] = digit;
            output_index = output_index - 1;

            value = div;
        }

        for i in 0:countof(digits_prefix) {
            output[output_index] = digits_prefix[countof(digits_prefix) - i - 1];
            output_index = output_index - 1;
        }
        if is_negative {
            output[output_index] = '-';
            output_index = output_index - 1;
        }

        return std::write_all(writer, output[output_index+1:countof(output)]);
    }
}

struct str {
    var bytes: []byte;

    func init(bytes: []byte) str {
        return (:str){.bytes = bytes};
    }

    func compare(lhs: *str, rhs: *str) ssize {
        var lhs_bytes = lhs.*.bytes;
        var rhs_bytes = rhs.*.bytes;
        var count = std::min[[:usize]](countof(lhs_bytes), countof(rhs_bytes));
        for i in 0:count {
            if lhs_bytes[i] != rhs_bytes[i] {
                return (:ssize)lhs_bytes[i] - (:ssize)rhs_bytes[i];
            }
        }
        return (:ssize)countof(lhs_bytes) - (:ssize)countof(rhs_bytes);
    }

    # Accepted format specifiers:
    #   ""  => verbatim (default)
    #   "e" => escaped
    func format(self: *std::str, writer: std::writer, fmt: []byte) std::result[[:usize, :[]byte]] {
        # Format specifier: ""
        if countof(fmt) == 0 {
            return std::write_all(writer, self.*.bytes);
        }

        # Format specifier: "e"
        if countof(fmt) == 1 and fmt[0] == 'e' {
            var written: usize = 0;
            var write_result = std::zeroed[[:std::result[[:usize, :[]byte]]]]();
            for i in 0:countof(self.*.bytes) {
                var c: byte = self.*.bytes[i];
                if c == '\0' {
                    write_result = std::write_all_accumulate(writer, "\\0", &written);
                    if write_result.is_error() {
                        return write_result;
                    }
                    continue;
                }
                if c == '\t' {
                    write_result = std::write_all_accumulate(writer, "\\t", &written);
                    if write_result.is_error() {
                        return write_result;
                    }
                    continue;
                }
                if c == '\n' {
                    write_result = std::write_all_accumulate(writer, "\\n", &written);
                    if write_result.is_error() {
                        return write_result;
                    }
                    continue;
                }
                if c == '\'' {
                    write_result = std::write_all_accumulate(writer, "\\\'", &written);
                    if write_result.is_error() {
                        return write_result;
                    }
                    continue;
                }
                if c == '\"' {
                    write_result = std::write_all_accumulate(writer, "\\\"", &written);
                    if write_result.is_error() {
                        return write_result;
                    }
                    continue;
                }
                if c == '\\' {
                    write_result = std::write_all_accumulate(writer, "\\\\", &written);
                    if write_result.is_error() {
                        return write_result;
                    }
                    continue;
                }
                write_result = std::write_all_accumulate(writer, (:[]byte){&c, 1}, &written);
                if write_result.is_error() {
                    return write_result;
                }
            }
            return std::result[[:usize, :[]byte]]::init_value(written);
        }

        std::formatter::invalid_format_specifier(fmt);
    }
}

struct input_reader {
    func read(self: *std::input_reader, buf: []byte) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret = sys::read(sys::STDIN_FILENO, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }
}

struct out_writer {
    func write(self: *std::out_writer, buf: []byte) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret = sys::write(sys::STDOUT_FILENO, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }
}

struct err_writer {
    func write(self: *std::err_writer, buf: []byte) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret = sys::write(sys::STDERR_FILENO, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }
}

# Returns the reader interface associated with the standard input stream.
func input() std::reader {
    const input = (:input_reader){};
    const input_itable = (:reader_itable){
        .read = std::input_reader::read
    };
    const input_reader = (:std::reader){
        .itable = &input_itable,
        .object = &input
    };
    return input_reader;
}

# Returns the writer interface associated with the standard output stream.
func out() std::writer {
    const out = (:out_writer){};
    const out_itable = (:writer_itable){
        .write = std::out_writer::write
    };
    const out_writer = (:std::writer){
        .itable = &out_itable,
        .object = &out
    };
    return out_writer;
}

# Returns the writer interface associated with the standard error stream.
func err() std::writer {
    const err = (:err_writer){};
    const err_itable = (:writer_itable){
        .write = std::err_writer::write
    };
    const err_writer = (:std::writer){
        .itable = &err_itable,
        .object = &err
    };
    return err_writer;
}

# Read from the provided reader, invoking the reader's `read` function
# repeatedly until either an end-of-input condition is reached or an error
# occurs.
#
# On success, this function returns a slice of bytes containing the read data,
# allocated using the provided allocator.
#
# On failure, this function returns a static string describing the failure.
func read_all(reader: std::reader, allocator: std::allocator) std::result[[:[]byte, :[]byte]] {
    var bytes = std::new_slice[[:byte]](allocator, 0);

    var buf = (:[4096]byte)[0...];
    for true {
        var read_result = reader.read(buf[0:countof(buf)]);
        if read_result.is_error() {
            std::delete_slice[[:byte]](allocator, bytes);
            return std::result[[:[]byte, :[]byte]]::init_error(read_result.error());
        }

        var read_size = read_result.value();
        if read_size == 0 {
            break;
        }

        var cur_count = countof(bytes);
        var new_count = cur_count + read_size;
        bytes = std::resize_slice[[:byte]](allocator, bytes, new_count);
        std::copy_slice[[:byte]](bytes[cur_count:new_count], buf[0:read_size]);
    }

    return std::result[[:[]byte, :[]byte]]::init_value(bytes);
}

# Read from the provided reader, invoking the reader's `read` function
# repeatedly until a newline is encountered, an end-of-input condition is
# reached, or an error occurs. If an end-of-input condition is encountered while
# reading a line, and the line is empty, an empty optional is returned. If an
# end-of-input condition is encountered while reading a non-empty line, it is
# treated as a newline.
#
# On success, this function returns a non-empty optional slice of bytes
# containing the read line without the ending newline, allocated using the
# provided allocator. If an end-of-input condition is encountered while reading
# an empty line, then an empty optional is returned.
#
# On failure, this function returns a static string describing the failure.
func read_line(reader: std::reader, allocator: std::allocator) std::result[[:std::optional[[:[]byte]], :[]byte]] {
    var bytes = std::new_slice[[:byte]](allocator, 0);

    var c = std::zeroed[[:byte]]();
    for true {
        var read_result = reader.read((:[]byte){&c, 1});
        if read_result.is_error() {
            std::delete_slice[[:byte]](allocator, bytes);
            return std::result[[:std::optional[[:[]byte]], :[]byte]]::init_error(read_result.error());
        }

        var read_size = read_result.value();
        if read_size == 0 {
            if countof(bytes) == 0 {
                # End-of-input encountered while reading an empty line.
                std::delete_slice[[:byte]](allocator, bytes);
                return std::result[[:std::optional[[:[]byte]], :[]byte]]::init_value(std::optional[[:[]byte]]::init_empty());
            }
            # End-of-input encountered while reading a non-empty line.
            break;
        }

        if c == '\n' {
            # End-of-line reached.
            break;
        }

        var cur_count = countof(bytes);
        var new_count = cur_count + read_size;
        bytes = std::resize_slice[[:byte]](allocator, bytes, new_count);
        std::copy_slice[[:byte]](bytes[cur_count:new_count], (:[]byte){&c, 1});

    }

    return std::result[[:std::optional[[:[]byte]], :[]byte]]::init_value(std::optional[[:[]byte]]::init_value(bytes));
}

# Write `countof(buf)` bytes using the provided writer, invoking the writer's
# `write` function repeatedly until either all bytes have been written or an
# error occurs.
func write_all(writer: std::writer, buf: []byte) std::result[[:usize, :[]byte]] {
    var written: usize = 0;
    for written < countof(buf) {
        var result = writer.write(buf[written:countof(buf)]);
        if result.is_error() {
            return result;
        }
        written = written + result.value();
    }
    return std::result[[:usize, :[]byte]]::init_value(written);
}

# Write `countof(buf)` bytes using the provided writer, invoking the writer's
# `write` function repeatedly until either all bytes have been written or an
# error occurs. This function behaves identically to `std::write_all`, but will
# additionally add the number of written bytes to the value at `written` on
# success. This behavior is useful when defining `format` member functions that
# require multiple `std::write_all` calls.
func write_all_accumulate(writer: std::writer, buf: []byte, written: *usize) std::result[[:usize, :[]byte]] {
    var result = std::write_all(writer, buf);
    if result.is_value() {
        *written = *written + result.value();
    }
    return result;
}


func write_format(writer: std::writer, format: []byte, args: []std::formatter) std::result[[:usize, :[]byte]] {
    # Current format argument index.
    var arg: usize = 0;

    # Total number of bytes written.
    var written: usize = 0;

    # Walking along the format string accumulating bytes to be written verbatim.
    #   "some{fmt}text"
    #    ^^^^     ^^^^ Walking along either of the byte spans "some" or "text".
    const STATE_WALKING: ssize = 0;

    # Inside of a `fmt` string.
    #   "some{fmt}text"
    #         ^^^-- Walking (fmtting) along the text between the '{' '}' bytes.
    const STATE_FMTTING: ssize = 1;

    # Current state.
    var state: ssize = STATE_WALKING;

    # Start and end indices of the current state.
    var start: usize = 0;
    var end: usize = start;

    for end < countof(format) {
        if state == STATE_WALKING {
            if format[end] != '{' and format[end] != '}' {
                # "some{fmt}text"
                #  ^^^^     ^^^^ Any non-'{' non-'}' character.
                end = end + 1;
                continue;
            }

            if (end + 1) == countof(format) {
                # "some{"
                #      ^
                # "some}"
                #      ^ End-of-format-string '{' or '}' character.
                std::formatter::invalid_format_string(format);
            }

            if format[end] == format[end + 1] {
                # "some{{text"
                #      ^^
                # "some}}text"
                #      ^^ Escaped '{' or '}' character.
                var res = std::write_all_accumulate(writer, format[start:end+1], &written);
                if res.is_error() {
                    return res;
                }
                start = end + 2;
                end = start;
                continue;
            }

            if format[end] == '}' {
                # "some}text"
                #      ^ End-of-fmt when not in the fmt-parsing state.
                std::formatter::invalid_format_string(format);
            }

            # "some{fmt}text"
            #      ^ Start of format specifier.
            var res = std::write_all_accumulate(writer, format[start:end], &written);
            if res.is_error() {
                return res;
            }
            start = end + 1;
            end = start;
            state = STATE_FMTTING;
            if arg == countof(args) {
                std::panic("invalid format argument count");
            }
            continue;
        }

        if state == STATE_FMTTING {
            if format[end] != '{' and format[end] != '}' {
                # "some{fmt}text"
                #       ^^^ Any non-'{' non-'}' character.
                end = end + 1;
                continue;
            }

            if (end + 1) < countof(format) and format[end] == format[end + 1] {
                # "some{f{{t}text"
                #        ^^
                # "some{f}}t}text"
                #        ^^ Escaped '{' or '}' character is not allowed inside
                #           a fmt string.
                std::formatter::invalid_format_string(format);
            }

            # "some{fmt}text"
            #          ^ End of format specifier.
            var res = args[arg].format(writer, format[start:end]);
            if res.is_error() {
                return res;
            }
            written = written + res.value();
            start = end + 1;
            end = start;
            arg = arg + 1;
            state = STATE_WALKING;
            continue;
        }

        std::panic("unreachable");
    }

    # "some{fmt"
    #          ^ End-of-format-string reached while in the formatting state.
    if state == STATE_FMTTING {
        std::formatter::invalid_format_string(format);
    }

    # "some{fmt}text"
    #           ^^^^ Write the remaining walked text.
    var res = std::write_all_accumulate(writer, format[start:end], &written);
    if res.is_error() {
        return res;
    }

    # Call with a format string "some {fmt} text" (N format specifiers) and N+M
    # format arguments for some non-zero M. Passing extra format arguments is a
    # hard error, but there is a specific check for this error *after* the rest
    # of the walked text has been written so that users will be able to observe
    # that an error occurred even though the full formatted string was written.
    if arg != countof(args) {
        std::panic("invalid format argument count");
    }

    return std::result[[:usize, :[]byte]]::init_value(written);
}

func print(writer: std::writer, bytes: []byte) void {
    var result = std::write_all(writer, bytes);
    if result.is_error() {
        std::panic(result.error());
    }
}

func print_line(writer: std::writer, bytes: []byte) void {
    std::print(writer, bytes);
    std::print(writer, "\n");
}

func print_format(writer: std::writer, format: []byte, args: []std::formatter) void {
    var result = std::write_format(writer, format, args);
    if result.is_error() {
        std::panic(result.error());
    }
}

func print_format_line(writer: std::writer, format: []byte, args: []std::formatter) void {
    std::print_format(writer, format, args);
    std::print(writer, "\n");
}

func new[[:T]](allocator: std::allocator) *T {
    var allocate_result = allocator.allocate(alignof(:T), sizeof(:T));
    if allocate_result.is_error() {
        std::panic(allocate_result.error());
    }
    return (:*T)allocate_result.value();
}

func delete[[:T]](allocator: std::allocator, object: *T) void {
    allocator.deallocate((:*byte)object, alignof(:T), sizeof(:T));
}

func new_slice[[:T]](allocator: std::allocator, count: usize) []T {
    var allocate_result = allocator.allocate(alignof(:T), count * sizeof(:T));
    if allocate_result.is_error() {
        std::panic(allocate_result.error());
    }
    return (:[]T){(:*T)allocate_result.value(), count};
}

func resize_slice[[:T]](allocator: std::allocator, slice: []T, new_count: usize) []T {
    var cur_count: usize = countof(slice);
    var cur_size: usize = cur_count * sizeof(:T);
    var new_size: usize = new_count * sizeof(:T);

    var cur_pointer: *byte = *((:**byte)&slice);
    var reallocate_result = allocator.reallocate(cur_pointer, alignof(:T), cur_size, new_size);
    if reallocate_result.is_error() {
        std::panic(reallocate_result.error());
    }

    return (:[]T){(:*T)reallocate_result.value(), new_count};
}

func delete_slice[[:T]](allocator: std::allocator, slice: []T) void {
    var pointer: *byte = *((:**byte)&slice);
    var size: usize = countof(slice) * sizeof(:T);
    allocator.deallocate(pointer, alignof(:T), size);
}

# Copy the elements of `source` into `destination`.The source and destination
# buffers must contain the same number of elements.
func copy_slice[[:T]](destination: []T, source: []T) void {
    if countof(destination) != countof(source) {
        std::panic("source and destination buffers have different sizes");
    }

    if countof(source) == 0 {
        # Nothing to copy.
        return;
    }

    # If the copy operation is being performed on two slices into the same
    # buffer then the direction in which the copy is performed does matter. Say
    # there is some buffer:
    #
    #    0  1  2  3  4
    #   [A][B][C][D][E]
    #
    # and the following copy operation is performed:
    #
    #   std::copy_slice(buf[0:3], buf[1:4]);
    #
    # With a forwards copy one gets the correct result:
    #
    #    0  1  2  3  4
    #   [A][B][C][D][E] <- initial buffer
    #   [B][B][C][D][E] <- copy first element
    #   [B][C][C][D][E] <- copy second element
    #   [B][C][D][D][E] <- copy third element
    #
    # But with a backwards copy one gets an incorrect result:
    #
    #    0  1  2  3  4
    #   [A][B][C][D][E] <- initial buffer
    #   [A][B][D][D][E] <- copy first element
    #   [A][D][D][D][E] <- copy second element
    #   [D][D][D][D][E] <- copy third element
    #
    # So when the start of `destination` appears before the start of `source`
    # the copy must be performed forwards, and when the start of `source`
    # appears before the start of `destination` then copy must be performed
    # backwards. When the start of `destination` and the start of `source` are
    # the same, the copy is arbitrarily chosen to be performed forwards.
    if &destination[0] <= &source[0] {
        # Copy forwards.
        for i in 0:countof(source) {
            destination[i] = source[i];
        }
    }
    else {
        # Copy backwards.
        for i in 0:countof(source) {
            var index: usize = countof(source) - 1 - i;
            destination[index] = source[index];
        }
    }
}

# Set every element of the provided slice to the provided value.
func fill_slice[[:T]](slice: []T, value: T) void {
    for i in 0:countof(slice) {
        slice[i] = value;
    }
}

# Returns a signed integer less than, equal to, or greater than zero if `lhs`
# is found, respectively, to be less than, equal to, or greater than `rhs`.
func compare[[:T]](lhs: *T, rhs: *T) ssize {
    return T::compare(lhs, rhs);
}

# Returns true if `lhs` is found to be equal to `rhs`.
func eq[[:T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) == 0;
}

# Returns true if `lhs` is found to be equal to `rhs`.
func ne[[:T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) != 0;
}

# Returns true if `lhs` is found to be less than `rhs`.
func lt[[:T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) < 0;
}

# Returns true if `lhs` is found to be less than or equal to `rhs`.
func le[[:T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) <= 0;
}

# Returns true if `lhs` is found to be greater than `rhs`.
func gt[[:T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) > 0;
}

# Returns true if `lhs` is found to be greater than or equal to `rhs`.
func ge[[:T]](lhs: *T, rhs: *T) bool {
    return T::compare(lhs, rhs) >= 0;
}

# Returns the minimum value of `x` and `y`, both of primitive type `T`.
func min[[:T]](x: T, y: T) T {
    if x < y {
        return x;
    }
    return y;
}

# Returns the maximum value of `x` and `y`, both of primitive type `T`.
func max[[:T]](x: T, y: T) T {
    if x > y {
        return x;
    }
    return y;
}

# Calculates the remainder of x and y (truncated towards zero).
# The remainder will have the same sign as the dividend.
#   std::rem[[:ssize]](+7, +3) => +1
#   std::rem[[:ssize]](+7, -3) => +1
#   std::rem[[:ssize]](-7, +3) => -1
#   std::rem[[:ssize]](-7, -3) => -1
func rem[[:T]](x: T, y: T) T {
    return x - y * (x / y);
}

const EXIT_SUCCESS: ssize = 0;
const EXIT_FAILURE: ssize = 1;

# Discontinue program execution.
func exit(status: ssize) void {
    sys::exit((:s32)status);
}

# Print the provided string to standard error, followed by a newline, before
# making a call to `std::terminate`. This function does not return.
func panic(why: []byte) void {
    var str = std::str::init(why);
    std::panic_format("{}", (:[]std::formatter)[std::formatter::init[[:std::str]](&str)]);
}

# Print the provided formatted string to standard error, followed by a newline,
# before making a call to `std::terminate`. This function does not return.
func panic_format(format: []byte, args: []std::formatter) void {
    const PANIC_PREAMBLE = "panic: ";
    std::print(std::err(), PANIC_PREAMBLE);
    std::print_format(std::err(), format, args);
    std::print(std::err(), "\n");
    std::exit(std::EXIT_FAILURE);
}

# Return an object of type `T` with all bytes (including padding) zeroed.
func zeroed[[:T]]() T {
    # TODO: Ensure that `object` is aligned to `alignof(:T)` once alignment
    # specification is added to variable & constant declarations. The x64
    # architecture allows unaligned memory access, so this current
    # implementation is a non-issue for the Linux x64 OS/ARCH target. However,
    # this function is not necessarily portable across other architectures.
    const object: [sizeof(:T)]byte = (:[sizeof(:T)]byte)[0...];
    return *(:*T)&object;
}
