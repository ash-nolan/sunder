namespace std::mem;
import "std/panic.sunder";

func copy[[:T]](dest: []T, source: []T) void {
    if countof(dest) < countof(source) {
        std::panic("destination buffer is too small");
    }

    if countof(source) == 0 {
        # Nothing to copy.
        return;
    }

    # If the copy operation is being performed on two slices into the same
    # buffer then the direction in which we copy matters. Say we have some
    # buffer:
    #
    #    0  1  2  3  4
    #   [A][B][C][D][E]
    #
    # and we perform the copy operation:
    #
    #   std::copy(buf[0:3], buf[1:4]);
    #
    # With a forwards copy we get the correct result:
    #
    #    0  1  2  3  4
    #   [A][B][C][D][E] <- initial buffer
    #   [B][B][C][D][E] <- copy first element
    #   [B][C][C][D][E] <- copy second element
    #   [B][C][D][D][E] <- copy thrird element
    #
    # But with a backwards copy we get an incorrect result.
    #
    #    0  1  2  3  4
    #   [A][B][C][D][E] <- initial buffer
    #   [A][B][D][D][E] <- copy first element
    #   [A][D][D][D][E] <- copy second element
    #   [D][D][D][D][E] <- copy thrird element
    #
    # So when the the start of dest appears before the start of source we need
    # to copy forwards, and when the start of source appears before the start
    # of dest then we need to copy backwards. When the start of dest and the
    # start of source are the same, we arbitrarily choose to copy forwards.
    if &dest[0] <= &source[0] {
        # Copy forwards.
        for i in 0:countof(source) {
            dest[i] = source[i];
        }
    }
    else {
        # Copy backwards.
        for i in 0:countof(source) {
            var index: usize = countof(source) - 1 - i;
            dest[index] = source[index];
        }
    }
}

func set[[:T]](buf: []T, value: T) void {
    for i in 0:countof(buf) {
        buf[i] = value;
    }
}

func zeroed[[:T]]() T {
    var mem: [sizeof(:T)]byte = (:[sizeof(:T)]byte)[0...];
    return *(:*T)&mem;
}
