namespace std;
import "std/core.sunder";

struct hash_map_element[[K, V]] {
    const _STATE_NIL: usize = 0;
    const _STATE_USE: usize = 1;
    const _STATE_DEL: usize = 2;
    var _state: usize;

    # The key associated with this element.
    #
    # The hash function and compare function of this key type are used for
    # insertion and lookup within the hash map. As such, mutation of the `key`
    # member would invalidate this element's corresponding hash map, and any
    # program that *does* perform such mutation is considered ill-formed.
    var _key: K;

    # The value associated with this element.
    #
    # Mutation of this member is permitted in well-formed programs.
    var _value: V;
}

struct hash_map[[K, V]] {
    var _allocator: std::allocator;
    var _elements: []hash_map_element[[K, V]];
    var _n: usize; # Number of USE entries in the map.
    var _q: usize; # Number of non-NIL entries in the map.

    func init(allocator: std::allocator) hash_map[[K, V]] {
        return (:hash_map[[K, V]]){
            ._allocator = allocator,
            ._elements = (:[]hash_map_element[[K, V]])[],
            ._n = 0,
            ._q = 0
        };
    }

    func fini(self: *hash_map[[K, V]]) void {
        if countof(self.*._elements) != 0 {
            std::slice[[hash_map_element[[K, V]]]]::delete(self.*._allocator, self.*._elements);
        }
    }

    func count(self: *hash_map[[K, V]]) usize {
        return self.*._n;
    }

    # Returns true if the map contains a key-value pair with the provided key.
    func contains(self: *hash_map[[K, V]], key: K) bool {
        var item = self.*.lookup(key);
        return item.is_value();
    }

    # Returns a non-empty optional containing the value associated with the
    # provided key if such a key-value pair exists in the map.
    func lookup(self: *hash_map[[K, V]], key: K) std::optional[[V]] {
        if countof(self.*._elements) == 0 {
            return std::optional[[V]]::init_empty();
        }

        var index = key.hash() % countof(self.*._elements);
        for self.*._elements[index]._state != hash_map_element[[K, V]]::_STATE_NIL {
            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_USE and std::eq[[K]](&key, &self.*._elements[index]._key) {
                return std::optional[[V]]::init_value(self.*._elements[index]._value);
            }
            index = (index + 1) % countof(self.*._elements);
        }
        return std::optional[[V]]::init_empty();
    }

    # Insert the provided key and value into the map. If a key-value pair
    # associated with the provided key exists, then it is overwritten and a
    # non-empty optional containing the existing key-value pair is returned.
    func insert(self: *hash_map[[K, V]], key: K, value: V) std::optional[[std::key_value_pair[[K, V]]]] {
        if countof(self.*._elements) == 0 {
            # Initial insert. An initial slice count of 16 was chosen
            # semi-arbitrarily. The initial slice count must be two or greater
            # in order to prevent the lookup loop from spinning forever.
            self.*._elements = std::slice[[hash_map_element[[K, V]]]]::new(self.*._allocator, 16);
            std::slice[[hash_map_element[[K, V]]]]::fill(self.*._elements, std::zeroed[[hash_map_element[[K, V]]]]());
        }
        elif 2 * (self.*._q + 1) > countof(self.*._elements) {
            # Insert at 50% occupancy. Create a new hash map with double the
            # existing element count, populate that map with this map's
            # key-value pairs, and then replace this map with the new map.
            var new = (:hash_map[[K, V]]){
                ._allocator = self.*._allocator,
                ._elements = std::slice[[hash_map_element[[K, V]]]]::new(self.*._allocator, countof(self.*._elements) * 2),
                ._n = 0,
                ._q = 0
            };
            for i in 0:countof(self.*._elements) {
                if self.*._elements[i]._state == hash_map_element[[K, V]]::_STATE_USE {
                    var existing = new.insert(self.*._elements[i]._key, self.*._elements[i]._value);
                    std::assert(existing.is_empty());
                }
            }
            std::slice[[hash_map_element[[K, V]]]]::delete(self.*._allocator, self.*._elements);
            *self = new;
        }

        var index = key.hash() % countof(self.*._elements);
        for true {
            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_NIL {
                self.*._elements[index] = (:hash_map_element[[K, V]]){
                    ._state = hash_map_element[[K, V]]::_STATE_USE,
                    ._key = key,
                    ._value = value
                };
                self.*._n = self.*._n + 1;
                self.*._q = self.*._q + 1;
                return std::optional[[std::key_value_pair[[K, V]]]]::init_empty();
            }

            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_DEL {
                self.*._elements[index] = (:hash_map_element[[K, V]]){
                    ._state = hash_map_element[[K, V]]::_STATE_USE,
                    ._key = key,
                    ._value = value
                };
                self.*._n = self.*._n + 1;
                return std::optional[[std::key_value_pair[[K, V]]]]::init_empty();
            }

            # _STATE_USE
            if std::eq[[K]](&key, &self.*._elements[index]._key) {
                var existing = self.*._elements[index];
                var kv = (:std::key_value_pair[[K, V]]){
                    .key = existing._key,
                    .value = existing._value
                };
                self.*._elements[index] = (:hash_map_element[[K, V]]){
                    ._state = hash_map_element[[K, V]]::_STATE_USE,
                    ._key = key,
                    ._value = value
                };
                return std::optional[[std::key_value_pair[[K, V]]]]::init_value(kv);
            }

            index = (index + 1) % countof(self.*._elements);
        }

        std::assert(false); # unreachable
        return std::optional[[std::key_value_pair[[K, V]]]]::init_empty();
    }

    # Remove the key-value pair associated with the provided key if such a
    # key-value pair exists in the map. Returns a non-empty optional containing
    # the key-value pair if the pair was removed.
    func remove(self: *hash_map[[K, V]], key: K) std::optional[[std::key_value_pair[[K, V]]]] {
        if countof(self.*._elements) == 0 {
            return std::optional[[std::key_value_pair[[K, V]]]]::init_empty();
        }

        var index = key.hash() % countof(self.*._elements);
        for self.*._elements[index]._state != hash_map_element[[K, V]]::_STATE_NIL {
            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_USE and std::eq[[K]](&key, &self.*._elements[index]._key) {
                var kv = (:std::key_value_pair[[K, V]]){
                    .key = self.*._elements[index]._key,
                    .value = self.*._elements[index]._value
                };
                self.*._elements[index]._state = hash_map_element[[K, V]]::_STATE_DEL;
                self.*._n = self.*._n - 1;
                return std::optional[[std::key_value_pair[[K, V]]]]::init_value(kv);
            }
            index = (index + 1) % countof(self.*._elements);
        }
        return std::optional[[std::key_value_pair[[K, V]]]]::init_empty();
    }
}

struct hash_map_iterator[[K, V]] {
    var _iterator: std::slice_iterator[[hash_map_element[[K, V]]]];

    func init(map: *std::hash_map[[K, V]]) hash_map_iterator[[K, V]] {
        return (:hash_map_iterator[[K, V]]){
            ._iterator = std::slice_iterator[[hash_map_element[[K, V]]]]::init(map.*._elements)
        };
    }

    func advance(self: *hash_map_iterator[[K, V]]) bool {
        for self.*._iterator.advance() {
            var current = self.*._iterator.current();
            if current.*._state != hash_map_element[[K, V]]::_STATE_USE {
                continue;
            }

            return true;
        }

        return false; # end-of-iteration
    }

    func current(self: *hash_map_iterator[[K, V]]) std::key_value_view[[K, V]] {
        var element = self.*._iterator.current();
        return (:std::key_value_view[[K, V]]){
            .key = &element.*._key,
            .value = &element.*._value
        };
    }
}
