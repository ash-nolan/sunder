namespace std;
import "std/core.sunder";

struct hash_map_element[[K, V]] {
    const _STATE_NIL: usize = 0;
    const _STATE_USE: usize = 1;
    const _STATE_DEL: usize = 2;
    var _state: usize;
    var _key: K;
    var _value: V;

    func key(self: *hash_map_element[[K, V]]) K {
        return self.*._key;
    }

    func value(self: *hash_map_element[[K, V]]) V {
        return self.*._value;
    }
}

struct hash_map[[K, V]] {
    var _allocator: std::allocator;
    var _elements: []hash_map_element[[K, V]];
    var _n: usize; # Number of USE entries in the map.
    var _q: usize; # Number of non-NIL entries in the map.

    func init(allocator: std::allocator) hash_map[[K, V]] {
        return (:hash_map[[K, V]]){
            ._allocator = allocator,
            ._elements = (:[]hash_map_element[[K, V]])[],
            ._n = 0,
            ._q = 0
        };
    }

    func fini(self: *hash_map[[K, V]]) void {
        if countof(self.*._elements) != 0 {
            std::delete_slice[[hash_map_element[[K, V]]]](self.*._allocator, self.*._elements);
        }
    }

    func count(self: *hash_map[[K, V]]) usize {
        return self.*._n;
    }

    func contains(self: *hash_map[[K, V]], key: K) bool {
        var item = self.*.lookup(key);
        return item.is_value();
    }

    func lookup(self: *hash_map[[K, V]], key: K) std::optional[[V]] {
        if countof(self.*._elements) == 0 {
            return std::optional[[V]]::init_empty();
        }

        var index = std::rem[[usize]](key.hash(), countof(self.*._elements));
        for self.*._elements[index]._state != hash_map_element[[K, V]]::_STATE_NIL {
            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_USE and std::eq[[K]](&key, &self.*._elements[index]._key) {
                return std::optional[[V]]::init_value(self.*._elements[index]._value);
            }
            index = std::rem[[usize]](index + 1, countof(self.*._elements));
        }
        return std::optional[[V]]::init_empty();
    }

    func insert(self: *hash_map[[K, V]], key: K, value: V) std::optional[[V]] {
        if countof(self.*._elements) == 0 {
            # Initial insert. An initial slice count of 16 was chosen
            # semi-arbitrarily. The initial slice count must be two or greater
            # in order to prevent the lookup loop from spinning forever.
            self.*._elements = std::new_slice[[hash_map_element[[K, V]]]](self.*._allocator, 16);
            std::fill_slice[[hash_map_element[[K, V]]]](self.*._elements, std::zeroed[[hash_map_element[[K, V]]]]());
        }
        elif 2 * (self.*._q + 1) > countof(self.*._elements) {
            # Insert at 50% occupancy. Create a new hash map with double the
            # existing element count, populate that map with this map's key-value
            # pairs, and then replace this map with the new map.
            var new = (:hash_map[[K, V]]){
                ._allocator = self.*._allocator,
                ._elements = std::new_slice[[hash_map_element[[K, V]]]](self.*._allocator, countof(self.*._elements) * 2),
                ._n = 0,
                ._q = 0
            };
            for i in 0:countof(self.*._elements) {
                if self.*._elements[i]._state == hash_map_element[[K, V]]::_STATE_USE {
                    new.insert(self.*._elements[i]._key, self.*._elements[i]._value);
                }
            }
            std::delete_slice[[hash_map_element[[K, V]]]](self.*._allocator, self.*._elements);
            *self = new;
        }

        var index = std::rem[[usize]](key.hash(), countof(self.*._elements));
        for true {
            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_NIL {
                self.*._elements[index] = (:hash_map_element[[K, V]]){
                    ._state = hash_map_element[[K, V]]::_STATE_USE,
                    ._key = key,
                    ._value = value
                };
                self.*._n = self.*._n + 1;
                self.*._q = self.*._q + 1;
                return std::optional[[V]]::init_empty();
            }

            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_DEL {
                self.*._elements[index] = (:hash_map_element[[K, V]]){
                    ._state = hash_map_element[[K, V]]::_STATE_USE,
                    ._key = key,
                    ._value = value
                };
                self.*._n = self.*._n + 1;
                return std::optional[[V]]::init_empty();
            }

            # _STATE_USE
            if std::eq[[K]](&key, &self.*._elements[index]._key) {
                var existing = self.*._elements[index]._value;
                self.*._elements[index] = (:hash_map_element[[K, V]]){
                    ._state = hash_map_element[[K, V]]::_STATE_USE,
                    ._key = key,
                    ._value = value
                };
                return std::optional[[V]]::init_value(existing);
            }

            index = std::rem[[usize]](index + 1, countof(self.*._elements));
        }
    }

    func remove(self: *hash_map[[K, V]], key: K) std::optional[[V]] {
        if countof(self.*._elements) == 0 {
            return std::optional[[V]]::init_empty();
        }

        var index = std::rem[[usize]](key.hash(), countof(self.*._elements));
        for self.*._elements[index]._state != hash_map_element[[K, V]]::_STATE_NIL {
            if self.*._elements[index]._state == hash_map_element[[K, V]]::_STATE_USE and std::eq[[K]](&key, &self.*._elements[index]._key) {
                self.*._elements[index]._state = hash_map_element[[K, V]]::_STATE_DEL;
                self.*._n = self.*._n - 1;
                return std::optional[[V]]::init_value(self.*._elements[index]._value);
            }
            index = std::rem[[usize]](index + 1, countof(self.*._elements));
        }
        return std::optional[[V]]::init_empty();
    }
}

struct hash_map_iterator[[K, V]] {
    var _iterator: std::slice_iterator[[hash_map_element[[K, V]]]];

    func init(map: *std::hash_map[[K, V]]) hash_map_iterator[[K, V]] {
        return (:hash_map_iterator[[K, V]]){
            ._iterator = std::slice_iterator[[hash_map_element[[K, V]]]]::init(map.*._elements)
        };
    }

    func advance(self: *hash_map_iterator[[K, V]]) bool {
        for true {
            if not self.*._iterator.advance() {
                return false; # end-of-iteration
            }

            var current = self.*._iterator.current();
            if current.*._state != hash_map_element[[K, V]]::_STATE_USE {
                continue;
            }

            return true;
        }
    }

    func current(self: *hash_map_iterator[[K, V]]) *hash_map_element[[K, V]] {
        return self.*._iterator.current();
    }
}
