namespace std;
import "std/io.sunder";
import "std/panic.sunder";

struct int[[:T]] {
    var value: T;

    func init(value: T) int[[:T]] {
        return (:int[[:T]]){.value = value};
    }

    func format(self: *std::int[[:T]], writer: std::writer, fmt: []byte) std::result[[:usize, :[]byte]] {
        # Currently the format specifiers accepted are:
        #   ""  => decimal (default)
        #   "d" => decimal
        #   "b" => binary
        #   "o" => octal
        #   "x" => hexadecimal (lower)
        #   "X" => hexadecimal (upper)
        #
        # All non-default format specifiers have a length of one byte.
        if countof(fmt) > 1 {
            std::panic_invalid_format_specifier(fmt);
        }

        const DIGITS_TABLE_COUNT: usize = 16;
        const DIGITS_TABLE_LOWER: [DIGITS_TABLE_COUNT]byte = (:[DIGITS_TABLE_COUNT]byte)[
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
        ];
        const DIGITS_TABLE_UPPER: [DIGITS_TABLE_COUNT]byte = (:[DIGITS_TABLE_COUNT]byte)[
            '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
        ];

        var radix: T = 10;
        var digits_prefix: []byte = "";
        var digits_table: []byte = DIGITS_TABLE_LOWER[0:DIGITS_TABLE_COUNT];

        if countof(fmt) != 0 {
            var c: byte = fmt[0];
            if c == 'd' {
                # Decimal defaults already set.
            }
            elif c == 'b' {
                radix = 2;
                digits_prefix = "0b";
            }
            elif c == 'o' {
                radix = 8;
                digits_prefix = "0o";
            }
            elif c == 'x' {
                radix = 16;
                digits_prefix = "0x";
            }
            elif c == 'X' {
                radix = 16;
                digits_prefix = "0x";
                digits_table = DIGITS_TABLE_UPPER[0:DIGITS_TABLE_COUNT];
            }
            else {
                std::panic_invalid_format_specifier(fmt);
            }
        }

        var written: usize = 0;
        var value: T = self.*.value;

        var is_negative: bool = value < 0;
        if is_negative {
            value = value * (:T)-1s;
        }

        # More than enough bytes to store the sign & digits of any number with
        # a size less than or equal to 64 bits.
        const OUTPUT_COUNT: usize = countof("-0b") + 64;
        var output: [OUTPUT_COUNT]byte = (:[OUTPUT_COUNT]byte)[0...];
        var output_index: usize = countof(output) - 1;

        for value != 0 {
            var div: T = value / radix;
            var rem: T = value - radix * (value / radix);

            var digit: byte = digits_table[(:usize)rem];
            output[output_index] = digit;
            output_index = output_index - 1;

            value = div;
        }
        for i in 0:countof(digits_prefix) {
            output[output_index] = digits_prefix[countof(digits_prefix) - i - 1];
            output_index = output_index - 1;
        }
        if is_negative {
            output[output_index] = '-';
            output_index = output_index - 1;
        }

        var res: std::result[[:usize, :[]byte]] = std::write_all(writer, output[output_index+1:countof(output)]);
        if res.is_error() {
            return res;
        }
        written = written + res.value();

        return std::result[[:usize, :[]byte]]::init_value(written);
    }

}
