namespace std;
import "std/core.sunder";
import "std/ptr.sunder";
import "std/page_allocator.sunder";
import "sys";

struct general_allocator_element {
    var _prev: *general_allocator_element; # nullable
    var _next: *general_allocator_element; # nullable

    var _start: *byte;
    var _align: usize;
    var _size: usize;

    func start(self: *general_allocator_element) *byte {
        return self.*._start;
    }

    func align(self: *general_allocator_element) usize {
        return self.*._align;
    }

    func size(self: *general_allocator_element) usize {
        return self.*._size;
    }
}

struct general_allocator {
    var _elements: *general_allocator_element;

    func init() general_allocator {
        return (:general_allocator){
            ._elements = std::ptr::null[[general_allocator_element]]()
        };
    }

    func fini(self: *general_allocator) void {
        for not std::ptr::is_null[[std::general_allocator_element]](self.*._elements) {
            self.*.deallocate(self.*._elements.*._start, self.*._elements.*._align, self.*._elements.*._size);
        }
    }

    func allocate(self: *general_allocator, align: usize, size: usize) std::result[[*byte, []byte]] {
        var offset = std::forward_align(sizeof(general_allocator_element), align);
        var result = std::page_allocator::the().*.allocate(sys::PAGE_SIZE, offset + size);
        if result.is_error() {
            return result;
        }

        var bytes = result.value();
        var element = (:*general_allocator_element)bytes;
        *element = (:general_allocator_element){
            ._prev = std::ptr::null[[general_allocator_element]](),
            ._next = std::ptr::null[[general_allocator_element]](),
            ._start = std::ptr::add[[byte]](bytes, offset),
            ._align = align,
            ._size = size
        };

        self.*._insert_element(element);
        return std::result[[*byte, []byte]]::init_value(element.*._start);
    }

    func reallocate(self: *general_allocator, ptr: *byte, align: usize, old_size: usize, new_size: usize) std::result[[*byte, []byte]] {
        var offset = std::forward_align(sizeof(general_allocator_element), align);
        var element = (:*general_allocator_element)std::ptr::sub[[byte]](ptr, offset);
        self.*._remove_element(element);

        var result = std::page_allocator::the().*.reallocate((:*byte)element, sys::PAGE_SIZE, old_size + offset, new_size + offset);
        if result.is_error() {
            return result;
        }

        var bytes = result.value();
        var element = (:*general_allocator_element)bytes;
        *element = (:general_allocator_element){
            ._prev = std::ptr::null[[general_allocator_element]](),
            ._next = std::ptr::null[[general_allocator_element]](),
            ._start = std::ptr::add[[byte]](bytes, offset),
            ._align = align,
            ._size = new_size
        };

        self.*._insert_element(element);
        return std::result[[*byte, []byte]]::init_value(element.*._start);
    }

    func deallocate(self: *general_allocator, ptr: *byte, align: usize, size: usize) void {
        var offset = std::forward_align(sizeof(general_allocator_element), align);
        var element = (:*general_allocator_element)std::ptr::sub[[byte]](ptr, offset);

        self.*._remove_element(element);
        std::page_allocator::the().*.deallocate((:*byte)element, sys::PAGE_SIZE, size + offset);
    }

    func _insert_element(self: *general_allocator, element: *general_allocator_element) void {
        if std::ptr::is_null[[std::general_allocator_element]](self.*._elements) {
            element.*._prev = element;
            element.*._next = element;
            self.*._elements = element;
            return;
        }

        element.*._prev = self.*._elements.*._prev;
        element.*._next = self.*._elements;
        element.*._prev.*._next = element;
        element.*._next.*._prev = element;
        self.*._elements = element;
    }

    func _remove_element(self: *general_allocator, element: *general_allocator_element) void {
        var prev = element.*._prev;
        var next = element.*._next;

        var is_only_element = self.*._elements == element and prev == next;
        if is_only_element {
            self.*._elements = std::ptr::null[[general_allocator_element]]();
            return;
        }

        prev.*._next = next;
        next.*._prev = prev;
        self.*._elements = next;
    }
}

struct general_allocator_iterator {
    var _general_allocator: *std::general_allocator;
    var _current: std::optional[[*general_allocator_element]];

    func init(general_allocator: *std::general_allocator) general_allocator_iterator {
        return (:general_allocator_iterator){
            ._general_allocator = general_allocator,
            ._current = std::optional[[*general_allocator_element]]::init_empty()
        };
    }

    func advance(self: *general_allocator_iterator) bool {
        if std::ptr::is_null[[std::general_allocator_element]](self.*._general_allocator.*._elements) {
            return false; # end-of-iteration
        }

        if self.*._current.is_empty() {
            self.*._current = std::optional[[*general_allocator_element]]::init_value(self.*._general_allocator.*._elements);
            return true; # start-of-iteration
        }

        self.*._current = std::optional[[*general_allocator_element]]::init_value(self.*._current.value().*._next);
        return self.*._current.value() != self.*._general_allocator.*._elements;
    }

    func current(self: *general_allocator_iterator) *general_allocator_element {
        if self.*._current.is_empty() {
            std::panic("invalid iterator");
        }

        return self.*._current.value();
    }
}
