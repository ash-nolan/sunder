namespace std;
import "std/core.sunder";
import "std/cptr.sunder";
import "std/page_allocator.sunder";
import "sys";

struct general_allocator_block {
    var _prev: *general_allocator_block;
    var _next: *general_allocator_block;

    var _start: *byte;
    var _align: usize;
    var _size: usize;

    func start(self: *general_allocator_block) *byte {
        return self.*._start;
    }

    func align(self: *general_allocator_block) usize {
        return self.*._align;
    }

    func size(self: *general_allocator_block) usize {
        return self.*._size;
    }
}

struct general_allocator {
    var _blocks: *general_allocator_block;

    func init() general_allocator {
        return (:general_allocator){
            ._blocks = (:*general_allocator_block)0u
        };
    }

    func fini(self: *general_allocator) void {
        for self.*._blocks != (:*general_allocator_block)0u {
            self.*.deallocate(self.*._blocks.*._start, self.*._blocks.*._align, self.*._blocks.*._size);
        }
    }

    func allocate(self: *general_allocator, align: usize, size: usize) std::result[[*byte, []byte]] {
        var offset: usize = std::align_forward(sizeof(general_allocator_block), align);
        var result = std::page_allocator::the().*.allocate(sys::PAGE_SIZE, offset + size);
        if result.is_error() {
            return result;
        }

        var bytes = result.value();
        var block = (:*general_allocator_block)bytes;
        *block = (:general_allocator_block){
            ._prev = (:*general_allocator_block)0u,
            ._next = (:*general_allocator_block)0u,
            ._start = std::cptr::add[[byte]](bytes, offset),
            ._align = align,
            ._size = size
        };

        self.*._insert_block(block);
        return std::result[[*byte, []byte]]::init_value(block.*._start);
    }

    func reallocate(self: *general_allocator, ptr: *byte, align: usize, old_size: usize, new_size: usize) std::result[[*byte, []byte]] {
        var offset: usize = std::align_forward(sizeof(general_allocator_block), align);
        var block = (:*general_allocator_block)std::cptr::sub[[byte]](ptr, offset);
        self.*._remove_block(block);

        var result = std::page_allocator::the().*.reallocate((:*byte)block, sys::PAGE_SIZE, old_size + offset, new_size + offset);
        if result.is_error() {
            return result;
        }

        var bytes = result.value();
        var block = (:*general_allocator_block)bytes;
        *block = (:general_allocator_block){
            ._prev = (:*general_allocator_block)0u,
            ._next = (:*general_allocator_block)0u,
            ._start = std::cptr::add[[byte]](bytes, offset),
            ._align = align,
            ._size = new_size
        };

        self.*._insert_block(block);
        return std::result[[*byte, []byte]]::init_value(block.*._start);
    }

    func deallocate(self: *general_allocator, ptr: *byte, align: usize, size: usize) void {
        var offset: usize = std::align_forward(sizeof(general_allocator_block), align);
        var block = (:*general_allocator_block)std::cptr::sub[[byte]](ptr, offset);

        self.*._remove_block(block);
        std::page_allocator::the().*.deallocate((:*byte)block, sys::PAGE_SIZE, size + offset);
    }

    func _insert_block(self: *general_allocator, block: *general_allocator_block) void {
        var is_first_block = self.*._blocks == (:*general_allocator_block)0u;
        if is_first_block {
            block.*._prev = block;
            block.*._next = block;
            self.*._blocks = block;
            return;
        }

        block.*._prev = self.*._blocks.*._prev;
        block.*._next = self.*._blocks;
        block.*._prev.*._next = block;
        block.*._next.*._prev = block;
        self.*._blocks = block;
    }

    func _remove_block(self: *general_allocator, block: *general_allocator_block) void {
        var prev = block.*._prev;
        var next = block.*._next;

        var is_only_block = self.*._blocks == block and prev == next;
        if is_only_block {
            self.*._blocks = (:*general_allocator_block)0u;
            return;
        }

        prev.*._next = next;
        next.*._prev = prev;
        self.*._blocks = next;
    }
}

struct general_allocator_iterator {
    var _general_allocator: *std::general_allocator;
    var _current: std::optional[[*general_allocator_block]];

    func init(general_allocator: *std::general_allocator) general_allocator_iterator {
        return (:general_allocator_iterator){
            ._general_allocator = general_allocator,
            ._current = std::optional[[*general_allocator_block]]::init_empty()
        };
    }

    func advance(self: *general_allocator_iterator) bool {
        if self.*._general_allocator.*._blocks == (:*general_allocator_block)0u {
            return false; # end-of-iteration
        }

        if self.*._current.is_empty() {
            self.*._current = std::optional[[*general_allocator_block]]::init_value(self.*._general_allocator.*._blocks);
            return true; # start-of-iteration
        }

        self.*._current = std::optional[[*general_allocator_block]]::init_value(self.*._current.value().*._next);
        return self.*._current.value() != self.*._general_allocator.*._blocks;
    }

    func current(self: *general_allocator_iterator) *general_allocator_block {
        if self.*._current.is_empty() {
            std::panic("invalid iterator");
        }

        return self.*._current.value();
    }
}
