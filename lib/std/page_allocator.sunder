namespace std;
import "std/core.sunder";
import "sys";

# Allocator that directly allocates, reallocates, and deallocates pages from
# the operating system using mmap and munmap.
struct page_allocator {
    func allocate(self_: *page_allocator, align: usize, size: usize) std::result[[*any, std::error]] {
        if align == 0 {
            if size == 0 {
                # Allocating zero bytes with an alignment of zero is a valid
                # use case when allocating for any zero-sized type:
                # allocate(alignof(:void), sizeof(:void)); Use NULL as the
                # canonical address for this situation.
                return std::result[[*any, std::error]]::init_value((:*any)0u);
            }
            return std::result[[*any, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        # If the requested alignment is larger than the page size then there is
        # no way for the kernel to map arbitrary page(s) for the allocation.
        if align > sys::PAGE_SIZE {
            return std::result[[*any, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        # The requested alignment must be a power of two. The expression:
        #   (x & (x - 1)) == 0
        # will evaluate as true for any non-zero x that is a power of two. We
        # check for an alignment of zero above, so it is safe to perform this
        # check here without the `x == 0 or ...` component that would normally
        # be required to prevent underflow.
        var is_power_of_two: bool = (align & (align - 1)) == 0;
        if not is_power_of_two {
            return std::result[[*any, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        # According to POSIX, a call to mmap with a len argument of zero shall
        # fail and no mapping shall be established. A request for zero bytes of
        # memory *is* a valid and common case (e.g. allocating a zero element
        # buffer), so we choose to return the NULL pointer as the "valid"
        # memory location.
        if size == 0 {
            return std::result[[*any, std::error]]::init_value((:*any)0u);
        }

        # NULL addr indicates no address hint.
        const addr = 0u;

        # Give the page(s) read and write permissions.
        const prot = sys::PROT_READ | sys::PROT_WRITE;

        # Create a private mapping not backed by a file.
        # The contents of the mapped region are initialized to zero.
        const flags = sys::MAP_PRIVATE | sys::MAP_ANONYMOUS;

        # Should be -1 when MAP_ANONYMOUS is specified.
        const fd = (:sys::sint)-1s;

        # Should be 0 when MAP_ANONYMOUS is specified.
        const off = (:sys::off_t)0u;

        var sysret: ssize = sys::mmap((:*any)addr, size, prot, flags, fd, off);
        if sysret < 0 {
            return std::result[[*any, std::error]]::init_error((:std::error)sys::error(-sysret));
        }

        return std::result[[*any, std::error]]::init_value((:*any)(:usize)sysret);
    }

    func reallocate(self: *page_allocator, ptr: *any, align: usize, old_size: usize, new_size: usize) std::result[[*any, std::error]] {
        var old_page_count = old_size / sys::PAGE_SIZE + (:usize)((old_size % sys::PAGE_SIZE) != 0);
        var new_page_count = new_size / sys::PAGE_SIZE + (:usize)((new_size % sys::PAGE_SIZE) != 0);
        if old_page_count == new_page_count {
            # Re-use existing allocated page(s).
            return std::result[[*any, std::error]]::init_value(ptr);
        }

        var result = self.*.allocate(align, new_size);
        if result.is_error() {
            return result;
        }
        var new: *any = result.value();

        # Number of bytes that will need to by copied from the old buffer to
        # the new buffer. If the new buffer has a smaller size then the old
        # buffer then we should only copy that smaller number of bytes.
        var copy_size: usize = old_size;
        if new_size < old_size {
            copy_size = new_size;
        }

        std::slice[[byte]]::copy((:[]byte){(:*byte)new, copy_size}, (:[]byte){(:*byte)ptr, copy_size});
        self.*.deallocate(ptr, align, old_size);
        return std::result[[*any, std::error]]::init_value(new);
    }

    func deallocate(self_: *page_allocator, ptr: *any, align: usize, size: usize) void {
        if align == 0 {
            if size != 0 {
                std::panic("invalid alignment");
            }
            # Calls to allocate with align of zero and size of zero are always
            # handed the NULL pointer as a result.
            if (:usize)ptr != 0 {
                std::panic("invalid pointer");
            }
            # Nothing to deallocate.
            return;
        }

        if size == 0 {
            # std::page_allocator::allocate will not perform a call to mmap
            # when the requested # allocation size is zero. Likewise, munmap
            # should *not* be called if the current buffer size is zero as
            # there is nothing to deallocate.
            return;
        }

        if align > sys::PAGE_SIZE {
            std::panic("invalid alignment");
        }
        var is_power_of_two: bool = (align & (align - 1)) == 0;
        if not is_power_of_two {
            std::panic("invalid alignment");
        }

        var sysret = sys::munmap(ptr, size);
        if sysret < 0 {
            std::panic("munmap error");
        }
    }

    func the() *page_allocator {
        const the = (:page_allocator){};
        return &the;
    }
}
