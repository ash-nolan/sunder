namespace std;
import "std/core.sunder";
import "sys";

struct page_allocator {
    func allocate(
        self: *page_allocator,
        align: usize,
        size: usize
    ) std::result[[:*byte, :[]byte]] {
        if align == 0 {
            if size == 0 {
                # Allocating zero bytes with an alignment of zero is a valid use
                # case when allocating for any zero-sized type:
                #   allocate(alignof(:void), sizeof(:void));
                # Use NULL as the canonical address for this situation.
                return std::result[[:*byte, :[]byte]]::init_value((:*byte)0u);
            }
            return std::result[[:*byte, :[]byte]]::init_error(
                std::allocator::ERROR_INVALID_ALIGNMENT);
        }

        # If the requested alignment is larger than the page size then there is
        # no way for the kernel to map arbitrary page(s) for the allocation.
        if align > sys::PAGE_SIZE {
            return std::result[[:*byte, :[]byte]]::init_error(
                std::allocator::ERROR_INVALID_ALIGNMENT);
        }

        # The requested alignment must be a power of two. The expression:
        #   (x & (x - 1)) == 0
        # will evaluate as true for any non-zero x that is a power of two. We
        # check for an alignment of zero above, so it is safe to perform this
        # check here without the `x == 0 or ...` component that would normally
        # be present in an correct is_power_of_two function.
        var is_power_of_two: bool = (align & (align - 1)) == 0;
        if not is_power_of_two {
            return std::result[[:*byte, :[]byte]]::init_error(
                std::allocator::ERROR_INVALID_ALIGNMENT);
        }

        # According to POSIX, a call to mmap with a len argument of zero shall
        # fail and no mapping shall be established. A request for zero bytes of
        # memory *is* a valid and common case (e.g. allocating a zero element
        # buffer), so we choose to return the NULL pointer as the "valid" memory
        # location.
        if size == 0 {
            return std::result[[:*byte, :[]byte]]::init_value((:*byte)0u);
        }

        # NULL addr indicates no address hint.
        const addr: usize = 0u;

        # Give the page(s) read and write permissions.
        const prot: ssize = sys::PROT_READ | sys::PROT_WRITE;

        # Create a private mapping not backed by a file.
        # The contents of the mapped region are initialized to zero.
        const flags: ssize = sys::MAP_PRIVATE | sys::MAP_ANONYMOUS;

        # Should be -1 when MAP_ANONYMOUS is specified.
        const fd: usize = (:usize)-1s;

        # Should be 0 when MAP_ANONYMOUS is specified.
        const off: usize = 0u;

        var sysret: ssize = sys::mmap(addr, size, prot, flags, fd, off);
        if sysret < 0 {
            return std::result[[:*byte, :[]byte]]::init_error("mmap error");
        }

        return std::result[[:*byte, :[]byte]]::init_value(
            (:*byte)(:usize)sysret);
    }

    func reallocate(
        self: *page_allocator,
        ptr: *byte,
        align: usize,
        old_size: usize,
        new_size: usize
    ) std::result[[:*byte, :[]byte]] {
        var allocate_result = self.*.allocate(align, new_size);
        if allocate_result.is_error() {
            return allocate_result;
        }
        var new: *byte = allocate_result.value();

        # Number of bytes that will need to by copied from the old buffer to the
        # new buffer. If the new buffer has a smaller size then the old buffer
        # then we should only copy that smaller number of bytes.
        var copy_size: usize = old_size;
        if new_size < old_size {
            copy_size = new_size;
        }
        std::copy_slice[[:byte]](
            (:[]byte){new, copy_size},
            (:[]byte){ptr, copy_size});

        self.*.deallocate(ptr, align, old_size);

        return std::result[[:*byte, :[]byte]]::init_value(new);
    }

    func deallocate(
        self: *page_allocator,
        ptr: *byte,
        align: usize,
        size: usize
    ) void {
        if align == 0 {
            if size != 0 {
                std::panic(std::allocator::ERROR_INVALID_ALIGNMENT);
            }
            # Calls to allocate with align of zero and size of zero are always
            # handed the NULL pointer as a result.
            if (:usize)ptr != 0 {
                std::panic(std::allocator::ERROR_INVALID_POINTER);
            }
            # Nothing to deallocate.
            return;
        }

        if size == 0 {
            # std::page_allocator::allocate will not perform a call to mmap when
            # the requested # allocation size is zero. Likewise, munmap should
            # *not* be called if the current buffer size is zero as there is
            # nothing to deallocate.
            return;
        }

        if align > sys::PAGE_SIZE {
            std::panic(std::allocator::ERROR_INVALID_ALIGNMENT);
        }
        var is_power_of_two: bool = (align & (align - 1)) == 0;
        if not is_power_of_two {
            std::panic(std::allocator::ERROR_INVALID_ALIGNMENT);
        }

        var sysret: ssize = sys::munmap((:usize)ptr, size);
        if sysret < 0 {
            std::panic("munmap error");
        }
    }

    func the() std::allocator {
        const the = (:page_allocator){};
        const the_itable = (:allocator_itable){
            .allocate = std::page_allocator::allocate,
            .reallocate = std::page_allocator::reallocate,
            .deallocate = std::page_allocator::deallocate
        };
        const the_allocator = (:std::allocator){
            .vtable = &the_itable,
            .object = &the
        };
        return the_allocator;
    }
}
