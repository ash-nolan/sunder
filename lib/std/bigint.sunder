namespace std;
import "std/core.sunder";
import "std/linear_allocator.sunder";
import "std/string.sunder";
import "std/vector.sunder";

struct bigint {
    # Allocator used to allocate limbs for this bigint. The allocator is also
    # used as the backing allocator for intermediate objects created while
    # performing arithmetic operations.
    var _allocator: std::allocator;
    # -1 if the integer <  0
    #  0 if the integer == 0
    # +1 if the integer >  0
    var _sign: ssize;
    # Magnitude of the integer, represented as a little endian list of u32.
    # Unsigned 32 bit integers are used as the limb type so that limb
    # arithmetic may be performed using 64 bit integers without loss of
    # information or integer out-of-range behavior. The integer zero will have
    # `countof(limbs) == 0`.
    var _limbs: []u32;

    # Number of bits in each limb of the integer.
    const _BITS_PER_LIMB: usize = sizeof(u32) * 8;

    func init(allocator: std::allocator) bigint {
        return (:bigint){
            ._allocator = allocator,
            ._sign = 0,
            ._limbs = std::slice[[u32]]::new(allocator, 0)
        };
    }

    func init_from_bigint(allocator: std::allocator, from: *bigint) bigint {
        var self = bigint::init(allocator);
        bigint::assign(&self, from);
        return self;
    }

    func init_from_int[[T]](allocator: std::allocator, int: T) bigint {
        std::assert(sizeof(T) <= sizeof(u64));
        if int >= 0 {
            var self = (:bigint){
                ._allocator = allocator,
                ._sign = +1s,
                ._limbs = std::slice[[u32]]::new(allocator, 2)
            };
            self._limbs[0] = (:u32)int;
            self._limbs[1] = (:u32)(int >> 32);
            self._normalize();
            return self;
        }

        var magnitude: u64 = std::zeroed[[u64]]();
        # Special case for the minimum value of a two's complement signed
        # integer, which will produce an integer out-of-range error when
        # multiplied by negative one, as the negated (positive) value is
        # un-representable as a two's complement signed type `T`.
        std::assert(T::MIN < 0);
        if int == T::MIN {
            magnitude = (:u64)T::MAX + 1;
        }
        else {
            magnitude = (:u64)((:T)-1s * int);
        }

        var self = (:bigint){
            ._allocator = allocator,
            ._sign = -1s,
            ._limbs = std::slice[[u32]]::new(allocator, 2)
        };
        self._limbs[0] = (:u32)magnitude;
        self._limbs[1] = (:u32)(magnitude >> 32);
        self._normalize();
        return self;
    }

    func init_from_str(allocator: std::allocator, str: []byte, radix: usize) std::result[[bigint, std::error]] {
        if radix != 0 and radix != 2 and radix != 8 and radix != 10 and radix != 16 {
            return std::result[[bigint, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        var cur: usize = 0;
        var end: usize = countof(str);

        # Parse optional sign (+ or -).
        var sign: ssize = +1;
        if (end - cur) > countof("+") and str[cur] == '+' {
            cur = cur + 1;
        }
        if (end - cur) > countof("-") and str[cur] == '-' {
            sign = -1;
            cur = cur + 1;
        }

        # Parse radix.
        if radix == 0 {
            var is_bin = (end - cur) >= countof("0b") and str[cur] == '0' and str[cur+1] == 'b';
            var is_oct = (end - cur) >= countof("0o") and str[cur] == '0' and str[cur+1] == 'o';
            var is_hex = (end - cur) >= countof("0x") and str[cur] == '0' and str[cur+1] == 'x';

            if is_bin {
                radix = 2;
                cur = cur + countof("0b");
            }
            elif is_oct {
                radix = 8;
                cur = cur + countof("0o");
            }
            elif is_hex {
                radix = 16;
                cur = cur + countof("0x");
            }
            else {
                radix = 10;
            }
        }
        var radix_bigint = (:bigint){
            ._allocator = std::zeroed[[std::allocator]](),
            ._sign = +1,
            ._limbs = (:[]u32)[(:u32)radix]
        };

        # Parse digits.
        if cur == end {
            return std::result[[bigint, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        var self = bigint::init(allocator);
        for cur != end {
            var c = str[cur];
            cur = cur + 1;

            var digit: usize = 0;
            if '0' <= c and c <= '9' {
                digit = (:usize)c - '0';
            }
            elif 'A' <= c and c <= 'F' {
                digit = (:usize)c - 'A' + 0xA;
            }
            elif 'a' <= c and c <= 'f' {
                digit = (:usize)c - 'a' + 0xA;
            }
            else {
                self.fini();
                return std::result[[bigint, std::error]]::init_error(std::error::PARSE_FAILURE);
            }

            if digit >= radix {
                self.fini();
                return std::result[[bigint, std::error]]::init_error(std::error::PARSE_FAILURE);
            }

            var digit_bigint = (:bigint){
                ._allocator = std::zeroed[[std::allocator]](),
                ._sign = +1,
                ._limbs = (:[]u32)[(:u32)digit]
            };
            bigint::mul(&self, &self, &radix_bigint);
            bigint::add(&self, &self, &digit_bigint);
        }

        self._sign = sign;
        self._normalize();
        return std::result[[bigint, std::error]]::init_value(self);
    }

    func fini(self: *bigint) void {
        std::slice[[u32]]::delete(self.*._allocator, self.*._limbs);
    }

    func to_int[[T]](self: *bigint) std::result[[T, std::error]] {
        std::assert(sizeof(T) <= sizeof(u64));
        var buf = (:[64]byte)[0...]; # More than enough space.
        var allocator = std::linear_allocator::init(buf[0:countof(buf)]);
        var allocator = std::allocator::init[[typeof(allocator)]](&allocator);
        var string = std::string::init_from_format(allocator, "{}", (:[]std::formatter)[std::formatter::init[[bigint]](self)]);
        return T::init_from_str(string.data(), 0);
    }

    func assign(self: *bigint, from: *bigint) void {
        if self == from {
            return;
        }

        self.*._sign = from.*._sign;
        self.*._limbs = std::slice[[u32]]::resize(self.*._allocator, self.*._limbs, countof(from.*._limbs));

        if self.*._sign != 0 {
            std::assert(countof(self.*._limbs) != 0);
            std::slice[[u32]]::copy(self.*._limbs, from.*._limbs);
        }
    }

    func compare(lhs: *bigint, rhs: *bigint) ssize {
        if lhs.*._sign > rhs.*._sign {
            return +1;
        }
        if lhs.*._sign < rhs.*._sign {
            return -1;
        }

        std::assert(lhs.*._sign == rhs.*._sign);
        var sign = lhs.*._sign;
        if countof(lhs.*._limbs) > countof(rhs.*._limbs) {
            return sign;
        }
        if countof(lhs.*._limbs) < countof(rhs.*._limbs) {
            return -sign;
        }

        std::assert(countof(lhs.*._limbs) == countof(rhs.*._limbs));
        var count = countof(lhs.*._limbs);
        for i in count {
            var limb_idx = count - i - 1;
            var lhs_limb = lhs.*._limbs[limb_idx];
            var rhs_limb = rhs.*._limbs[limb_idx];

            if (lhs_limb > rhs_limb) {
                return sign;
            }
            if (lhs_limb < rhs_limb) {
                return -sign;
            }
        }

        return 0;
    }

    func hash(self: *bigint) usize {
        # TODO: This hash function was chosen because it was easy to implement.
        # The uniformity of the hash has *not* been properly evaluated.
        var hash: usize = 0;
        for i in countof(self.*._limbs) {
            hash = std::wrapping_add[[usize]](hash, (:usize)self.*._limbs[i]);
        }
        return hash;
    }

    # Accepted format specifiers:
    #   ""  => decimal (default)
    #
    # TODO: Currently, only the default format specifier is supported in order
    # to keep this function simple. In the future is would be nice to add the
    # rest of the format specifiers that the builtin integer types support:
    # "d", "b", "o", "x", and "X".
    func format(self: *bigint, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if countof(fmt) != 0 {
            return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        var magnitude = bigint::init_from_bigint(self.*._allocator, self);
        bigint::assign(&magnitude, self);
        bigint::abs(&magnitude, &magnitude);
        defer { magnitude.fini(); }

        var radix = bigint::init_from_str(self.*._allocator, "10", 10);
        var radix = radix.value();
        defer { radix.fini(); }

        var output = std::vector[[byte]]::init(self.*._allocator);
        defer { output.fini(); }

        if magnitude._sign == 0 {
            std::assert(countof(self.*._limbs) == 0);
            # Write a single zero digit.
            output.insert(0u, '0');
        }
        for magnitude._sign != 0 {
            std::assert(countof(self.*._limbs) != 0);

            var div = bigint::init(self.*._allocator);
            defer { div.fini(); }
            var rem = bigint::init(self.*._allocator);
            defer { rem.fini(); }
            bigint::_divrem(&div, &rem, &magnitude, &radix);

            if rem._sign == 0 {
                output.insert(0u, '0');
            }
            elif rem._sign == +1 {
                std::assert(countof(rem._limbs) == 1);
                const DIGITS_TABLE = (:[]byte)[
                    '0', '1', '2', '3', '4',
                    '5', '6', '7', '8', '9'
                ];
                var digit = DIGITS_TABLE[(:usize)rem._limbs[0]];
                output.insert(0u, digit);
            }
            else {
                std::panic("unreachable");
            }

            bigint::assign(&magnitude, &div);
        }

        if self.*._sign == -1 {
            output.insert(0u, '-');
        }
        return std::write_all(writer, output.data());
    }

    # res = -rhs
    func neg(res: *bigint, rhs: *bigint) void {
        bigint::assign(res, rhs);
        # +1 * -1 == -1
        # -1 * -1 == +1
        #  0 * -1 ==  0
        res.*._sign = res.*._sign * -1;
    }

    # res = abs(rhs)
    func abs(res: *bigint, rhs: *bigint) void {
        bigint::assign(res, rhs);
        # +1 * +1 == +1
        # -1 * -1 == +1
        #  0 *  0 ==  0
        res.*._sign = rhs.*._sign * rhs.*._sign;
    }

    # res = lhs + rhs
    func add(res: *bigint, lhs: *bigint, rhs: *bigint) void {
        # 0 + rhs == rhs
        if lhs.*._sign == 0 {
            bigint::assign(res, rhs);
            return;
        }
        # lhs + 0 == lhs
        if rhs.*._sign == 0 {
            bigint::assign(res, lhs);
            return;
        }
        # (+lhs) + (-rhs) == (+lhs) - (+rhs)
        if (lhs.*._sign == +1) and (rhs.*._sign == -1) {
            var tmp_rhs = bigint::init(res.*._allocator);
            bigint::neg(&tmp_rhs, rhs);
            bigint::sub(res, lhs, &tmp_rhs);
            tmp_rhs.fini();
            return;
        }
        # (-lhs) + (+rhs) == (+rhs) - (+lhs)
        if (lhs.*._sign == -1) and (rhs.*._sign == +1) {
            var tmp_lhs = bigint::init(res.*._allocator);
            bigint::neg(&tmp_lhs, lhs);
            bigint::sub(res, rhs, &tmp_lhs);
            tmp_lhs.fini();
            return;
        }

        # (+lhs) + (+rhs) == +(lhs + rhs)
        # (-lhs) + (-rhs) == -(lhs + rhs)
        std::assert(lhs.*._sign == rhs.*._sign);
        var sign = lhs.*._sign;
        var lhs_limb_count = countof(lhs.*._limbs);
        var rhs_limb_count = countof(rhs.*._limbs);
        var limb_count = 1 + *std::max[[usize]](&lhs_limb_count, &rhs_limb_count);
        var tmp_res = (:bigint){
            ._allocator = res.*._allocator,
            ._sign = sign,
            ._limbs = std::slice[[u32]]::new(res.*._allocator, limb_count)
        };

        var carry: u64 = 0;
        for i in countof(tmp_res._limbs) {
            var lhs_limb: u64 = 0;
            if i < countof(lhs.*._limbs) {
                lhs_limb = (:u64)lhs.*._limbs[i]; # upcast
            }
            var rhs_limb: u64 = 0;
            if i < countof(rhs.*._limbs) {
                rhs_limb = (:u64)rhs.*._limbs[i]; # upcast
            }
            var tot: u64 = lhs_limb + rhs_limb + carry;

            tmp_res._limbs[i] = (:u32)tot;
            carry = (:u64)(tot > (:u64)u32::MAX);
        }
        std::assert(carry == 0);

        tmp_res._normalize();
        bigint::assign(res, &tmp_res);
        tmp_res.fini();
    }

    # res = lhs - rhs
    func sub(res: *bigint, lhs: *bigint, rhs: *bigint) void {
        # 0 - rhs == -(rhs)
        if lhs.*._sign == 0 {
            bigint::neg(res, rhs);
            return;
        }
        # lhs - 0 == lhs
        if rhs.*._sign == 0 {
            bigint::assign(res, lhs);
            return;
        }
        # (+lhs) - (-rhs) == (+lhs) + (+rhs)
        if (lhs.*._sign == +1) and (rhs.*._sign == -1) {
            var tmp_rhs = bigint::init(res.*._allocator);
            bigint::neg(&tmp_rhs, rhs);
            bigint::add(res, lhs, &tmp_rhs);
            tmp_rhs.fini();
            return;
        }
        # (-lhs) - (+rhs) == (-lhs) + (-rhs)
        if (lhs.*._sign == -1) and (rhs.*._sign == +1) {
            var tmp_rhs = bigint::init(res.*._allocator);
            bigint::neg(&tmp_rhs, rhs);
            bigint::add(res, lhs, &tmp_rhs);
            tmp_rhs.fini();
            return;
        }

        # (+lhs) - (+rhs) == +(lhs - rhs)
        # (-lhs) - (-rhs) == -(lhs - rhs)
        std::assert(lhs.*._sign == rhs.*._sign);
        var sign = lhs.*._sign;
        # Note that the expression (lhs - rhs) will require flipping the sign
        # of the result if the magnitude of lhs is greater than the magnitude
        # of rhs:
        # (+5) - (+3) == +2
        # (+3) - (+5) == -2
        # (-5) - (-3) == -2
        # (-3) - (-5) == +2
        var cmp = bigint::compare(lhs, rhs);
        var neg = ((sign == +1) and (cmp < 0)) or ((sign == -1) and (cmp > 0));
        if neg {
            var tmp = lhs;
            lhs = rhs;
            rhs = tmp;
        }

        var lhs_limb_count = countof(lhs.*._limbs);
        var rhs_limb_count = countof(rhs.*._limbs);
        var limb_count = *std::max[[usize]](&lhs_limb_count, &rhs_limb_count);
        var tmp_res = (:bigint){
            ._allocator = res.*._allocator,
            ._sign = sign,
            ._limbs = std::slice[[u32]]::new(res.*._allocator, limb_count)
        };

        var borrow: u64 = 0;
        for i in countof(tmp_res._limbs) {
            var lhs_limb: u64 = 0;
            if i < countof(lhs.*._limbs) {
                lhs_limb = (:u64)lhs.*._limbs[i]; # upcast
            }
            var rhs_limb: u64 = 0;
            if i < countof(rhs.*._limbs) {
                rhs_limb = (:u64)rhs.*._limbs[i]; # upcast
            }
            var tot: u64 = std::wrapping_sub[[u64]](std::wrapping_sub[[u64]](lhs_limb, rhs_limb), borrow);

            tmp_res._limbs[i] = (:u32)tot;
            borrow = (:u64)(tot > (:u64)u32::MAX);
        }
        std::assert(borrow == 0);

        if (neg) {
            bigint::neg(&tmp_res, &tmp_res);
        }
        tmp_res._normalize();
        bigint::assign(res, &tmp_res);
        tmp_res.fini();
    }

    # res = lhs * rhs
    func mul(res: *bigint, lhs: *bigint, rhs: *bigint) void {
        # 0 * rhs == 0
        # lhs * 0 == 0
        if lhs.*._sign == 0 or rhs.*._sign == 0 {
            var zero = bigint::init(res.*._allocator);
            defer { zero.fini(); }
            bigint::assign(res, &zero);
            return;
        }

        # Algorithm M (Multiplication of Nonnegative Integers)
        # Source: Art of Computer Programming, Volume 2: Seminumerical
        #         Algorithms (Third Edition) page. 268.
        var count = countof(lhs.*._limbs) + countof(rhs.*._limbs);
        var tmp_w = bigint::init(res.*._allocator); # abs(res)
        tmp_w._resize(count);

        var w = tmp_w._limbs;
        var u = lhs.*._limbs;
        var v = rhs.*._limbs;
        var m = countof(lhs.*._limbs);
        var n = countof(rhs.*._limbs);
        const b: u64 = (:u64)u32::MAX + 1;
        for j in n {
            if v[j] == 0 {
                w[j + m] = 0;
                continue;
            }
            var k: u64 = 0;
            for i in m {
                var u_limb: u64 = 0;
                if i < countof(u) {
                    u_limb = (:u64)u[i];
                }

                var v_limb: u64 = 0;
                if j < countof(v) {
                    v_limb = (:u64)v[j];
                }

                var t: u64 = u_limb * v_limb + (:u64)w[i + j] + k;
                w[i + j] = (:u32)(t % b);
                k = t / b;
                assert(k <= b);
            }
            w[j + m] = (:u32)k;
        }

        tmp_w._sign = lhs.*._sign * rhs.*._sign;
        tmp_w._normalize();
        bigint::assign(res, &tmp_w);
        tmp_w.fini();
    }

    # res = lhs / rhs
    func div(res: *bigint, lhs: *bigint, rhs: *bigint) void {
        var rem = bigint::init(res.*._allocator);
        defer { rem.fini(); }
        bigint::_divrem(res, &rem, lhs, rhs);
    }

    # res = lhs % rhs
    func rem(res: *bigint, lhs: *bigint, rhs: *bigint) void {
        var div = bigint::init(res.*._allocator);
        defer { div.fini(); }
        bigint::_divrem(&div, res, lhs, rhs);
    }

    func _resize(self: *bigint, new_count: usize) void {
        var cur_count = countof(self.*._limbs);
        if new_count <= cur_count {
            self.*._limbs = std::slice[[u32]]::resize(self.*._allocator, self.*._limbs, new_count);
            return;
        }

        self.*._limbs = std::slice[[u32]]::resize(self.*._allocator, self.*._limbs, new_count);
        std::slice[[u32]]::fill(self.*._limbs[cur_count:new_count], 0);
    }

    func _normalize(self: *bigint) void {
        var count = countof(self.*._limbs);
        for count != 0 and self.*._limbs[count - 1] == 0 {
            count = count - 1;
        }

        self.*._limbs = std::slice[[u32]]::resize(self.*._allocator, self.*._limbs, count);
        if (count == 0) {
            self.*._sign = 0;
        }
    }

    func _magnitude_bit_count(self: *bigint) usize {
        if countof(self.*._limbs) == 0 {
            return 0;
        }

        var top = self.*._limbs[countof(self.*._limbs) - 1];
        var top_bit_count = 0u;
        for top != 0 {
            top_bit_count = top_bit_count + 1;
            top = top >> 1;
        }

        return (countof(self.*._limbs) - 1) * bigint::_BITS_PER_LIMB + top_bit_count;
    }

    func _magnitude_set_bit(self: *bigint, n: usize, value: bool) void {
        var limb_idx = n / bigint::_BITS_PER_LIMB;
        if limb_idx >= countof(self.*._limbs) {
            if not value {
                # The abstact unallocated bit is already zero so re-setting it
                # to zero does not change the representation of self. Return
                # early rather than going through the trouble of resizeing and
                # then normalizing for what is essentially a NOP.
                return;
            }
            self.*._resize(limb_idx + 1);
        }

        var plimb: *u32 = &self.*._limbs[limb_idx];
        var mask = 1u32 << (n % bigint::_BITS_PER_LIMB);
        if (value) {
            *plimb = *plimb | mask;
        }
        else {
            *plimb = *plimb & ~mask;
        }

        if self.*._sign == 0 and value {
            # If the integer was zero (i.e. had sign zero) before and a bit was
            # just flipped "on" then treat that integer as it if turned from
            # the integer zero to a positive integer.
            self.*._sign = +1;
        }
        self.*._normalize();
    }

    func _magnitude_get_bit(self: *bigint, n: usize) bool {
        if n >= (countof(self.*._limbs) * bigint::_BITS_PER_LIMB) {
            return false;
        }

        var limb = self.*._limbs[n / bigint::_BITS_PER_LIMB];
        var mask = 1u32 << (n % bigint::_BITS_PER_LIMB);
        return (limb & mask) != 0;
    }

    func _magnitude_shiftl(self: *bigint, nbits: usize) void {
        if nbits == 0 {
            return;
        }
        if self.*._sign == 0 {
            return;
        }

        bigint::_magnitude_shiftl_limbs(self, nbits / bigint::_BITS_PER_LIMB);
        for n in (nbits % bigint::_BITS_PER_LIMB) {
            if (self.*._limbs[countof(self.*._limbs) - 1] & 0x80000000u32) != 0 {
                self.*._resize(countof(self.*._limbs) + 1);
                self.*._limbs[countof(self.*._limbs) - 1] = 0x00000000u32;
            }

            # [limb0 << 1][limb1 << 1 | msbit(limb0)][limb2 << 1 | msbit(limb1)]...
            var i = countof(self.*._limbs) - 1;
            for i > 0 {
                self.*._limbs[i] = self.*._limbs[i] << 1;
                if (self.*._limbs[i - 1] & 0x80000000u32) != 0 {
                    self.*._limbs[i] = self.*._limbs[i] | 0x00000001u32;
                }

                i = i - 1;
            }
            self.*._limbs[0] = self.*._limbs[0] << 1u;
        }
    }

    # Shift left by nlimbs number of limbs.
    # Example:
    #      -0xFFEE shifted by nlimbs=2 becomes -0xFFEE0000 with 8-bit limbs.
    func _magnitude_shiftl_limbs(self: *bigint, nlimbs: usize) void {
        if nlimbs == 0 {
            return;
        }

        self.*._resize(countof(self.*._limbs) + nlimbs);
        std::slice[[u32]]::copy(
            self.*._limbs[nlimbs : countof(self.*._limbs)],
            self.*._limbs[0 : countof(self.*._limbs) - nlimbs]);
        std::slice[[u32]]::fill(self.*._limbs[0:nlimbs], 0u32);
    }

    # div = lhs / rhs
    # rem = lhs % rhs
    # The allocator of `div` is used to allocate intermediate objects.
    func _divrem(div: *bigint, rem: *bigint, lhs: *bigint, rhs: *bigint) void {
        # lhs / 0 == undefined
        if (rhs.*._sign == 0) {
            std::panic("divide by zero");
        }

        # Binary Long Division Algorithm
        # Source: https://en.wikipedia.org/wiki/Division_algorithm#Long_division
        #
        # The following algorithm, the binary version of the famous long
        # division, will divide N by D, placing the quotient in Q and the
        # remainder in R. In the following code, all values are treated as
        # unsigned integers.
        #
        # if D = 0 then error(DivisionByZeroException) end
        # Q := 0                  -- Initialize quotient and remainder to zero
        # R := 0
        # for i := n − 1 .. 0 do  -- Where n is number of bits in N
        #   R := R << 1           -- Left-shift R by 1 bit
        #   R(0) := N(i)          -- Set the least-significant bit of R equal
        #                            to bit i of the numerator
        #   if R ≥ D then
        #     R := R − D
        #     Q(i) := 1
        #   end
        # end
        var Q = bigint::init(div.*._allocator); # abs(div)
        var R = bigint::init(div.*._allocator); # abs(rem)
        var N = bigint::init(div.*._allocator); # abs(lhs)
        bigint::abs(&N, lhs);
        var D = bigint::init(div.*._allocator); # abs(rhs)
        bigint::abs(&D, rhs);
        var i = bigint::_magnitude_bit_count(lhs);
        for i != 0 {
            i = i - 1;
            bigint::_magnitude_shiftl(&R, 1);
            bigint::_magnitude_set_bit(&R, 0, bigint::_magnitude_get_bit(&N, i));
            if bigint::compare(&R, &D) >= 0 {
                bigint::sub(&R, &R, &D);
                bigint::_magnitude_set_bit(&Q, i, true);
            }
        }

        # printf("%2d %2d\n", +7 / +3, +7 % +3); // 2  1
        # printf("%2d %2d\n", +7 / -3, +7 % -3); //-2  1
        # printf("%2d %2d\n", -7 / +3, -7 % +3); //-2 -1
        # printf("%2d %2d\n", -7 / -3, -7 % -3); // 2 -1
        # ISO-IEC-9899-1999 Section 6.5.5 - Multiplicative operators:
        # > When integers are divided, the result of the / operator is the
        # > algebraic quotient with any fractional part discarded. If the
        # > quotient a/b is representable, the expression (a/b)*b + a%b shall
        # > equal a.
        Q._sign = lhs.*._sign * rhs.*._sign;
        R._sign = lhs.*._sign;

        Q._normalize();
        bigint::assign(div, &Q);
        R._normalize();
        bigint::assign(rem, &R);
        Q.fini();
        R.fini();
        N.fini();
        D.fini();
    }
}
