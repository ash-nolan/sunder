namespace std;
import "std/core.sunder";
import "sys";

struct file {
    var _fd: sys::sint;

    # Open a file for reading.
    const OPEN_READ: usize = 0b001;
    # Open a file for writing.
    # The file is created if it does not exist.
    # The file is truncated if it does exist.
    const OPEN_WRITE: usize = 0b010;
    # Open a file for writing (appended).
    # The file is created if it does not exist.
    # Data is appended to the end of the file when written.
    const OPEN_APPEND: usize = 0b100;

    func open(path: []byte, mode: usize) std::result[[std::file, std::error]] {
        var flags: sys::sint = 0;
        if mode == 0 {
            # OPEN_READ, OPEN_WRITE, or OPEN_APPEND must be selected.
            return std::result[[std::file, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }
        if (mode & OPEN_WRITE != 0) and (mode & OPEN_APPEND != 0) {
            # Attempted open with both non-appending and appending write modes.
            return std::result[[std::file, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        if (mode & OPEN_READ != 0) and (mode & OPEN_WRITE != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_TRUNC;
        }
        elif (mode & OPEN_READ != 0) and (mode & OPEN_APPEND != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_APPEND;
        }
        elif mode & OPEN_READ != 0 {
            flags = sys::O_RDONLY;
        }
        elif mode & OPEN_WRITE != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_TRUNC;
        }
        elif mode & OPEN_APPEND != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_APPEND;
        }
        else {
            std::panic("unreachable");
        }

        if countof(path) >= sys::PATH_MAX {
            return std::result[[std::file, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::slice[[byte]]::copy(path_cstr[0:countof(path)], path);

        var sysret = sys::open(&path_cstr[0], flags, 0o666);
        if sysret < 0 {
            return std::result[[std::file, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        var file = (:std::file){._fd = (:sys::sint)sysret};
        return std::result[[std::file, std::error]]::init_value(file);
    }

    func close(self: *file) std::result[[void, std::error]] {
        var sysret = sys::close(self.*._fd);
        if sysret < 0 {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[void, std::error]]::init_value(void::init());
    }

    func read(self: *file, buf: []byte) std::result[[usize, std::error]] {
        if countof(buf) == 0 {
            return std::result[[usize, std::error]]::init_value(0);
        }

        var sysret = sys::read(self.*._fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[usize, std::error]]::init_value((:usize)sysret);
    }

    func write(self: *file, buf: []byte) std::result[[usize, std::error]] {
        if countof(buf) == 0 {
            return std::result[[usize, std::error]]::init_value(0);
        }

        var sysret = sys::write(self.*._fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[usize, std::error]]::init_value((:usize)sysret);
    }

    # Seek from the start of the file.
    const SEEK_START: usize = (:usize)sys::SEEK_SET;
    # Seek from the current position of the file position indicator.
    const SEEK_CURRENT: usize = (:usize)sys::SEEK_CUR;
    # Seek from the end of the file.
    const SEEK_END: usize = (:usize)sys::SEEK_END;

    # NOTE: Seeking past the end of a file on Linux and then writing to that
    # position will create a "hole" that is read as NUL bytes by subsequent
    # read operations until the hole is filled in.
    func seek(self: *file, offset: ssize, from: usize) std::result[[void, std::error]] {
        var sysret = sys::lseek(self.*._fd, offset, (:sys::uint)from);
        if sysret < 0 {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[void, std::error]]::init_value(std::zeroed[[void]]());
    }

    func tell(self: *file) std::result[[usize, std::error]] {
        var sysret = sys::lseek(self.*._fd, 0, sys::SEEK_CUR);
        if sysret < 0 {
            return std::result[[usize, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[usize, std::error]]::init_value((:usize)sysret);
    }

    # Create an empty file if it does not exist.
    func create(path: []byte)  std::result[[void, std::error]] {
        var result = std::file::open(path, std::file::OPEN_WRITE);
        if result.is_error() {
            return std::result[[void, std::error]]::init_error(result.error());
        }

        var file = result.value();
        return file.close();
    }

    # Remove a file.
    func remove(path: []byte) std::result[[void, std::error]] {
        if countof(path) >= sys::PATH_MAX {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::slice[[byte]]::copy(path_cstr[0:countof(path)], path);

        var sysret = sys::unlink(&path_cstr[0]);
        if sysret < 0 {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[void, std::error]]::init_value(void::init());
    }
}

struct directory {
    var _fd: sys::sint;
    var _buf: [1024]byte;
    var _buf_idx: usize;
    var _buf_end: usize;
    var _current: std::optional[[std::result[[[]byte, std::error]]]];

    func open(path: []byte) std::result[[std::directory, std::error]] {
        var flags: sys::sint = sys::O_RDONLY | sys::O_DIRECTORY | sys::O_CLOEXEC;

        if countof(path) >= sys::PATH_MAX {
            return std::result[[std::directory, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::slice[[byte]]::copy(path_cstr[0:countof(path)], path);

        var sysret = sys::open(&path_cstr[0], flags, 0);
        if sysret < 0 {
            return std::result[[std::directory, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        var directory = (:std::directory){
            ._fd = (:sys::sint)sysret,
            ._buf = (:[1024]byte)[0...],
            ._buf_idx = 0,
            ._buf_end = 0,
            ._current = std::optional[[std::result[[[]byte, std::error]]]]::init_empty()
        };
        return std::result[[std::directory, std::error]]::init_value(directory);
    }

    func close(self: *directory) std::result[[void, std::error]] {
        var sysret = sys::close(self.*._fd);
        if sysret < 0 {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[void, std::error]]::init_value(void::init());
    }

    # Advance the current directory entry.
    func advance(self: *directory) bool {
        if self.*._buf_idx >= self.*._buf_end {
            var sysret = sys::getdents(self.*._fd, (:*sys::linux_dirent)&self.*._buf[0], (:sys::uint)countof(self.*._buf));
            if sysret == 0 {
                self.*._current = std::optional[[std::result[[[]byte, std::error]]]]::init_empty();
                return false; # end-of-iteration
            }
            if sysret < 0 {
                var result = std::result[[[]byte, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
                self.*._current = std::optional[[std::result[[[]byte, std::error]]]]::init_value(result);
                return true;
            }

            self.*._buf_idx = 0;
            self.*._buf_end = (:usize)sysret;
        }

        var dirent = (:*sys::linux_dirent)&self.*._buf[self.*._buf_idx];
        var result = std::result[[[]byte, std::error]]::init_value(std::cstr::data(&dirent.*.d_name));
        self.*._current = std::optional[[std::result[[[]byte, std::error]]]]::init_value(result);
        self.*._buf_idx = self.*._buf_idx + (:usize)dirent.*.d_reclen;
        return true;
    }

    # Returns the current directory entry name or an error result if an IO
    # error occurred while reading this directory.
    #
    # A value result may be invalidated by the next call to
    # `std::directory::advance` or `std::directory::close`.
    #
    # An error result is a static string.
    func current(self: *directory) std::result[[[]byte, std::error]] {
        if self.*._current.is_empty() {
            std::panic("invalid iterator");
        }
        return self.*._current.value();
    }

    # Create an empty directory if it does not exist.
    func create(path: []byte)  std::result[[void, std::error]] {
        if countof(path) >= sys::PATH_MAX {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::slice[[byte]]::copy(path_cstr[0:countof(path)], path);

        var sysret = sys::mkdir(&path_cstr[0], 0o666);
        if sysret < 0 {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[void, std::error]]::init_value(void::init());
    }

    # Remove an empty directory.
    func remove(path: []byte) std::result[[void, std::error]] {
        if countof(path) >= sys::PATH_MAX {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::slice[[byte]]::copy(path_cstr[0:countof(path)], path);

        var sysret = sys::rmdir(&path_cstr[0]);
        if sysret < 0 {
            return std::result[[void, std::error]]::init_error((:std::error)&sys::ERRORS[(:usize)-sysret]);
        }

        return std::result[[void, std::error]]::init_value(void::init());
    }
}
