namespace std;
import "std/core.sunder";
import "sys";

struct file {
    # The Linux kernel uses `unsigned int fd` for the file descriptor parameter
    # of system calls instead of the traditional `int fd` parameter seen in
    # libc. The internal `struct fd` associated with this processes' file
    # descriptor table is indexed using this unsigned integer, with
    # out-of-bounds file descriptors producing an EBADF syscall error. The
    # `std::file` struct uses an `unsigned int` (`sys::uint` in Sunder) to
    # match the kernel data type.
    var _fd: sys::uint;

    # Open a file for reading.
    const OPEN_READ: usize = 0b001;
    # Open a file for writing.
    # The file is created if it does not exist.
    # The file is truncated if it does exist.
    const OPEN_WRITE: usize = 0b010;
    # Open a file for writing (appended).
    # The file is created if it does not exist.
    # Data is appended to the end of the file when written.
    const OPEN_APPEND: usize = 0b100;

    func open(path: []byte, mode: usize) std::result[[std::file, []byte]] {
        var flags: s32 = 0;
        if mode == 0 {
            # OPEN_READ, OPEN_WRITE, or OPEN_APPEND must be selected.
            return std::result[[std::file, []byte]]::init_error(sys::ERRNO_STRS[(:usize)sys::EINVAL]);
        }
        if (mode & OPEN_WRITE != 0) and (mode & OPEN_APPEND != 0) {
            # Attempted open with both non-appending and appending write modes.
            return std::result[[std::file, []byte]]::init_error(sys::ERRNO_STRS[(:usize)sys::EINVAL]);
        }

        if (mode & OPEN_READ != 0) and (mode & OPEN_WRITE != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_TRUNC;
        }
        elif (mode & OPEN_READ != 0) and (mode & OPEN_APPEND != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_APPEND;
        }
        elif mode & OPEN_READ != 0 {
            flags = sys::O_RDONLY;
        }
        elif mode & OPEN_WRITE != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_TRUNC;
        }
        elif mode & OPEN_APPEND != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_APPEND;
        }
        else {
            std::panic("unreachable");
        }

        if countof(path) >= sys::PATH_MAX {
            # Path is too long. The path must be less than sys::PATH_MAX bytes
            # so that a NUL-terminated buffer of sys::PATH_MAX bytes may be
            # constructed without a buffer overflow.
            return std::result[[std::file, []byte]]::init_error(sys::ERRNO_STRS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::slice[[byte]]::copy(path_cstr[0:countof(path)], path);

        var sysret = sys::open(&path_cstr[0], flags, 0o666);
        if sysret < 0 {
            return std::result[[std::file, []byte]]::init_error(sys::ERRNO_STRS[(:usize)-sysret]);
        }

        var file = (:std::file){._fd = (:sys::uint)sysret};
        return std::result[[std::file, []byte]]::init_value(file);
    }

    func close(self: *file) std::result[[void, []byte]] {
        var sysret = sys::close(self.*._fd);
        if sysret < 0 {
            return std::result[[void, []byte]]::init_error(sys::ERRNO_STRS[(:usize)-sysret]);
        }

        return std::result[[void, []byte]]::init_value(std::zeroed[[void]]());
    }

    func read(self: *file, buf: []byte) std::result[[usize, []byte]] {
        if countof(buf) == 0 {
            return std::result[[usize, []byte]]::init_value(0);
        }

        var sysret = sys::read(self.*._fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, []byte]]::init_error(sys::ERRNO_STRS[(:usize)-sysret]);
        }

        return std::result[[usize, []byte]]::init_value((:usize)sysret);
    }

    func write(self: *file, buf: []byte) std::result[[usize, []byte]] {
        if countof(buf) == 0 {
            return std::result[[usize, []byte]]::init_value(0);
        }

        var sysret = sys::write(self.*._fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[usize, []byte]]::init_error(sys::ERRNO_STRS[(:usize)-sysret]);
        }

        return std::result[[usize, []byte]]::init_value((:usize)sysret);
    }

    # Seek from the start of the file.
    const SEEK_START: usize = (:usize)sys::SEEK_SET;
    # Seek from the current position of the file position indicator.
    const SEEK_CURRENT: usize = (:usize)sys::SEEK_CUR;
    # Seek from the end of the file.
    const SEEK_END: usize = (:usize)sys::SEEK_END;

    func seek(self: *file, offset: ssize, from: usize) std::result[[void, []byte]] {
        # TODO: Seeking past the end of a file with `lseek` on Linux and then
        # writing to that position will create a "hole" that is read as NUL
        # bytes by subsequent read operations until the hole is filled in.
        #
        # The Sunder standard library can continue handle this case by matching
        # whatever the underlying system implementation does, but this drifts
        # into the realm of non-portable/undefined behavior. Consider
        # explicitly defining the behavior when seeking past the end of a file.
        var sysret = sys::lseek(self.*._fd, offset, (:sys::uint)from);
        if sysret < 0 {
            return std::result[[void, []byte]]::init_error(sys::ERRNO_STRS[(:usize)-sysret]);
        }

        return std::result[[void, []byte]]::init_value(std::zeroed[[void]]());
    }

    func tell(self: *file) std::result[[usize, []byte]] {
        var sysret = sys::lseek(self.*._fd, 0, sys::SEEK_CUR);
        if sysret < 0 {
            return std::result[[usize, []byte]]::init_error(sys::ERRNO_STRS[(:usize)-sysret]);
        }

        return std::result[[usize, []byte]]::init_value((:usize)sysret);
    }
}
