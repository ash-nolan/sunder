namespace std::fs;
import "std/core.sunder";
import "sys";

# Open a file for reading.
const OPEN_READ: usize = 0b001;

# Open a file for writing.
# The file is created if it does not exist.
# The file is truncated if it does exist.
const OPEN_WRITE: usize = 0b010;

# Open a file for writing (appended).
# The file is created if it does not exist.
# Data is appended to the end of the file when written.
const OPEN_APPEND: usize = 0b100;

# Seek from the start of the file.
const SEEK_START: usize = (:usize)sys::SEEK_SET;

# Seek from the current position of the file position indicator.
const SEEK_CURRENT: usize = (:usize)sys::SEEK_CUR;

# Seek from the end of the file.
const SEEK_END: usize = (:usize)sys::SEEK_END;

struct file {
    var fd: ssize;

    func open(path: []byte, mode: usize) std::result[[:std::fs::file, :[]byte]] {
        var flags: s32 = 0;
        if mode == 0 {
            # OPEN_READ, OPEN_WRITE, or OPEN_APPEND must be selected.
            return std::result[[:std::fs::file, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)sys::EINVAL]);
        }
        if (mode & OPEN_WRITE != 0) and (mode & OPEN_APPEND != 0) {
            # Attempted open with both non-appending and appending write modes.
            return std::result[[:std::fs::file, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)sys::EINVAL]);
        }

        if (mode & OPEN_READ != 0) and (mode & OPEN_WRITE != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_TRUNC;
        }
        elif (mode & OPEN_READ != 0) and (mode & OPEN_APPEND != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_APPEND;
        }
        elif mode & OPEN_READ != 0 {
            flags = sys::O_RDONLY;
        }
        elif mode & OPEN_WRITE != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_TRUNC;
        }
        elif mode & OPEN_APPEND != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_APPEND;
        }
        else {
            std::panic("unreachable");
        }

        if countof(path) >= sys::PATH_MAX {
            # Path is too long. The path must be less than sys::PATH_MAX bytes
            # so that a NUL-terminated buffer of of sys::PATH_MAX bytes may be
            # constructed without a buffer overflow.
            return std::result[[:std::fs::file, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)sys::EINVAL]);
        }
        var path_cstr = (:[sys::PATH_MAX]byte)[0...];
        std::copy_slice[[:byte]](path_cstr[0:countof(path)], path);

        var sysret = sys::open(&path_cstr[0], flags, 0o666);
        if sysret < 0 {
            return std::result[[:std::fs::file, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:std::fs::file, :[]byte]]::init_value((:std::fs::file){.fd = sysret});
    }

    func close(self: *std::fs::file) std::result[[:void, :[]byte]] {
        var sysret = sys::close((:u32)self.*.fd);
        if sysret < 0 {
            return std::result[[:void, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:void, :[]byte]]::init_value(std::zeroed[[:void]]());
    }

    func read(self: *std::fs::file, buf: []byte) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret = sys::read((:u32)self.*.fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }

    func write(self: *std::fs::file, buf: []byte) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret = sys::write((:u32)self.*.fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }

    func seek(self: *std::fs::file, offset: ssize, from: usize) std::result[[:void, :[]byte]] {
        # TODO: Seeking past the end of a file with `lseek` on Linux and then
        # writing to that position will create a "hole" that is read as NUL
        # bytes by subsequent read operations until the hole is filled in.
        #
        # The Sunder standard library can continue handle this case by matching
        # whatever the underlying system implementation does, but this drifts
        # into the realm of non-portable/undefined behavior. Consider
        # explicitly defining the behavior when seeking past the end of a file.
        var sysret = sys::lseek((:u32)self.*.fd, offset, (:u32)from);
        if sysret < 0 {
            return std::result[[:void, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:void, :[]byte]]::init_value(std::zeroed[[:void]]());
    }

    func tell(self: *std::fs::file) std::result[[:usize, :[]byte]] {
        var sysret = sys::lseek((:u32)self.*.fd, 0, sys::SEEK_CUR);
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }
}
