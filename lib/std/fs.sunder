namespace std::fs;
import "std/alloc.sunder";
import "std/core.sunder";
import "sys/sys.sunder";

struct error {
    var code: ssize;

    func format(
        self: *std::fs::error,
        writer: std::writer,
        fmt: []byte
    ) std::result[[:usize, :[]byte]] {
        if countof(fmt) != 0 {
            std::formatter::invalid_format_specifier(fmt);
        }
        return std::write_all(writer, sys::ERRNO_STRINGS[(:usize)self.*.code]);
    }
}

# Open the file for reading.
const OPEN_READ: usize = 0b001;

# Open the file for writing.
# The file is created if it does not exist.
# The file is truncated if it does exist.
const OPEN_WRITE: usize = 0b010;

# Open the file for writing.
# The file is created if it does not exist.
# Data is appended to the end of the file when written.
const OPEN_APPEND: usize = 0b100;

# Seek from the start of the file.
const SEEK_START: usize = (:usize)sys::SEEK_SET;

# Seek from the current position of the file position indicator.
const SEEK_CURRENT: usize = (:usize)sys::SEEK_CUR;

# Seek from the end of the file.
const SEEK_END: usize = (:usize)sys::SEEK_END;

struct file {
    var fd: ssize;

    func open(
        path: []byte,
        mode: usize
    ) std::result[[:std::fs::file, :std::fs::error]] {
        var flags: s32 = 0;
        if mode == 0 {
            # OPEN_READ, OPEN_WRITE, or OPEN_APPEND must be selected.
            return std::result[[:std::fs::file, :std::fs::error]]::init_error(
                (:std::fs::error){.code = sys::EINVAL});
        }
        if (mode & OPEN_WRITE != 0) and (mode & OPEN_APPEND != 0) {
            # Attempted open with both non-appending and appending write modes.
            return std::result[[:std::fs::file, :std::fs::error]]::init_error(
                (:std::fs::error){.code = sys::EINVAL});
        }

        if (mode & OPEN_READ != 0) and (mode & OPEN_WRITE != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_TRUNC;
        }
        elif (mode & OPEN_READ != 0) and (mode & OPEN_APPEND != 0) {
            flags = sys::O_RDWR | sys::O_CREAT | sys::O_APPEND;
        }
        elif mode & OPEN_READ != 0 {
            flags = sys::O_RDONLY;
        }
        elif mode & OPEN_WRITE != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_TRUNC;
        }
        elif mode & OPEN_APPEND != 0 {
            flags = sys::O_WRONLY | sys::O_CREAT | sys::O_APPEND;
        }
        else {
            std::panic("unreachable");
        }

        if countof(path) >= sys::PATH_MAX {
            # Path is too long. The path must be less than sys::PATH_MAX bytes
            # so that a NUL-terminated buffer of of sys::PATH_MAX bytes may be
            # constructed without a buffer overflow.
            return std::result[[:std::fs::file, :std::fs::error]]::init_error(
                (:std::fs::error){.code = sys::EINVAL});
        }
        var path_cstr: [sys::PATH_MAX]byte = (:[sys::PATH_MAX]byte)[0...];
        std::copy_slice[[:byte]](path_cstr[0:countof(path)], path);

        var sysret: ssize = sys::open(&path_cstr[0], flags, 0o666);
        if sysret < 0 {
            return std::result[[:std::fs::file, :std::fs::error]]::init_error(
                (:std::fs::error){.code = -sysret});
        }

        return std::result[[:std::fs::file, :std::fs::error]]::init_value(
            (:std::fs::file){.fd = sysret});
    }

    func close(self: *std::fs::file) std::result[[:void, :std::fs::error]] {
        var sysret: ssize = sys::close((:u32)self.*.fd);
        if sysret < 0 {
            return std::result[[:void, :std::fs::error]]::init_error(
                (:std::fs::error){.code = -sysret});
        }

        return std::result[[:void, :std::fs::error]]::init_value(
            std::zeroed[[:void]]());
    }

    func read(
        self: *std::fs::file,
        buf: []byte
    ) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret: ssize =
            sys::read((:u32)self.*.fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(
                sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }

    func write(
        self: *std::fs::file,
        buf: []byte
    ) std::result[[:usize, :[]byte]] {
        if countof(buf) == 0 {
            return std::result[[:usize, :[]byte]]::init_value(0);
        }

        var sysret: ssize =
            ::sys::write((:u32)self.*.fd, &buf[0u], countof(buf));
        if sysret < 0 {
            return std::result[[:usize, :[]byte]]::init_error(
                ::sys::ERRNO_STRINGS[(:usize)-sysret]);
        }

        return std::result[[:usize, :[]byte]]::init_value((:usize)sysret);
    }

    func seek(
        self: *std::fs::file,
        offset: ssize,
        from: usize
    ) std::result[[:void, :std::fs::error]] {
        # TODO: Seeking past the end of a file with `lseek` on Linux and then
        # writing to that position will create a "hole" that is read as NUL
        # bytes by subsequent read operations until the hole is filled in.
        #
        # The Sunder standard library can continue handle this case by matching
        # whatever the underlying system implementation does, but this drifts
        # into the realm of non-portable/undefined behavior. Consider
        # explicitly defining the behavior when seeking past the end of a file.
        var sysret: ssize = sys::lseek((:u32)self.*.fd, offset, (:u32)from);
        if sysret < 0 {
            return std::result[[:void, :std::fs::error]]::init_error(
                (:std::fs::error){.code = -sysret});
        }

        return std::result[[:void, :std::fs::error]]::init_value(
            std::zeroed[[:void]]());
    }

    func tell(self: *std::fs::file) std::result[[:usize, :std::fs::error]] {
        var sysret: ssize = sys::lseek((:u32)self.*.fd, 0, sys::SEEK_CUR);
        if sysret < 0 {
            return std::result[[:usize, :std::fs::error]]::init_error(
                (:std::fs::error){.code = -sysret});
        }

        return std::result[[:usize, :std::fs::error]]::init_value(
            (:usize)sysret);
    }
}
