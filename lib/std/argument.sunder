namespace std;
import "std/core.sunder";
import "sys";

struct argument_iterator {
    var _argv: **byte;
    var _bytes: []byte;
    var _index: std::optional[[usize]];

    # Initialize an argument iterator using the arguments provided by the
    # hosted environment at program startup.
    #
    # The behavior of this function is undefined for programs executing in a
    # freestanding environment. The behavior of this function is undefined if
    # the Sunder `main` function was not used as the program entry point.
    func init() argument_iterator {
        return argument_iterator::init_from_argv(sys::argv);
    }

    # Initialize an argument iterator from a C-style argument vector. The
    # provided argv *must* contain a NULL-terminated list of NUL-terminated
    # strings in accordance ISO/IEC 9899:1999 section 5.1.2.2.1.
    func init_from_argv(argv: **byte) argument_iterator {
        return (:argument_iterator){
            ._argv = argv,
            ._bytes = std::zeroed[[[]byte]](),
            ._index = std::optional[[usize]]::init_empty()
        };
    }

    func advance(self: *argument_iterator) bool {
        if self.*._index.is_empty() {
            self.*._index = std::optional[[usize]]::init_value(0); # start-of-iteration
        }
        else {
            self.*._index = std::optional[[usize]]::init_value(self.*._index.value() + 1);
        }

        var arg = std::ptr[[*byte]]::add(self.*._argv, self.*._index.value());
        if std::ptr[[byte]]::is_null(*arg) {
            return false; # end of iteration
        }

        self.*._bytes = std::cstr::view_str(*arg);
        return true;
    }

    func current(self: *argument_iterator) *[]byte {
        if self.*._index.is_empty() {
            std::panic("invalid iterator");
        }

        var arg = std::ptr[[*byte]]::add(self.*._argv, self.*._index.value());
        if std::ptr[[byte]]::is_null(*arg) {
            std::panic("invalid iterator");
        }
        return &self.*._bytes;
    }
}

struct argopt {
    # Option string, such as "a" in `-a` or the "file" `--file foo.txt`.
    #
    # Parsed option arguments must be separated from their option string within
    # the argument list, (e.g. `--file foo.txt` not `--file=foo.txt`.
    var _str: []byte;

    # True if the option requires an additional argument.
    var _arg: bool;

    func init(str: []byte, arg: bool) argopt {
        return (:argopt){
            ._str = str,
            ._arg = arg
        };
    }
}

struct argument_parser {
    var _options: []std::argopt;
    var _iterator: argument_iterator;
    var _verbatim: bool;
    var _opt: std::optional[[[]byte]];
    var _arg: std::optional[[[]byte]];

    # Initialize an argument parser using using the arguments provided by the
    # hosted environment at program startup. The first argument (program name)
    # is skipped and *not* treated as an argument by the parser.
    #
    # The behavior of this function is undefined for programs executing in a
    # freestanding environment. The behavior of this function is undefined if
    # the Sunder `main` function was not used as the program entry point.
    func init(options: []std::argopt) argument_parser {
        return std::argument_parser::init_from_argv(options, sys::argv);
    }

    # Initialize an argument parser from a C-style argument vector. The
    # provided argv *must* contain a NULL-terminated list of NUL-terminated
    # strings in accordance ISO/IEC 9899:1999 section 5.1.2.2.1.
    func init_from_argv(options: []std::argopt, argv: **byte) argument_parser {
        var self = (:argument_parser){
            ._options = options,
            ._iterator = std::argument_iterator::init_from_argv(argv),
            ._verbatim = false,
            ._opt = std::optional[[[]byte]]::init_empty(),
            ._arg = std::optional[[[]byte]]::init_empty()
        };

        # Skip past the first argument (program name).
        self._iterator.advance();

        return self;
    }

    func advance(self: *argument_parser) bool {
        self.*._opt = std::optional[[[]byte]]::init_empty();
        self.*._arg = std::optional[[[]byte]]::init_empty();

        if not self.*._iterator.advance() {
            return false;
        }

        var str = *self.*._iterator.current();
        if self.*._verbatim {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # The argument "--" signals that all following arguments should be
        # interpreted verbatim and not parsed as option strings.
        if std::str::eq(str, "--") {
            self.*._verbatim = true;
            return self.*.advance();
        }

        # The argument "-" is *not* treated as the start of an option string
        # since "-" is traditionally used to denote the standard input file.
        if std::str::eq(str, "-") {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # Positional argument.
        if not std::str::starts_with(str, "-") {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # Option strings of the form "-<option>", "--<option>", etc. Remove the
        # leading dashes so that `str` contains only the text of the option.
        for std::str::starts_with(str, "-") {
            str = str[countof("-"):countof(str)];
        }

        var idx = std::optional[[usize]]::init_empty();
        for i in countof(self.*._options) {
            if std::str::eq(str, self.*._options[i]._str) {
                idx = std::optional[[usize]]::init_value(i);
                break;
            }
        }
        if idx.is_empty() {
            std::print_format_line(
                std::err(),
                "error: unrecognized option `{}`",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&str)]);
            std::exit(std::EXIT_FAILURE);
        }

        self.*._opt = std::optional[[[]byte]]::init_value(str);
        if not self.*._options[idx.value()]._arg {
            return true;
        }

        if not self.*._iterator.advance() {
            std::print_format_line(
                std::err(),
                "error: missing required argument for option `{}`",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&str)]);
            std::exit(std::EXIT_FAILURE);
        }
        self.*._arg = std::optional[[[]byte]]::init_value(*self.*._iterator.current());
        return true;
    }

    func check_option(self: *argument_parser, opt: []byte) bool {
        if self.*._opt.is_empty() {
            return false;
        }
        return std::str::eq(self.*._opt.value(), opt);
    }

    func option(self: *argument_parser) std::optional[[[]byte]] {
        return self.*._opt;
    }

    func option_value(self: *argument_parser) []byte {
        if self.*._opt.is_empty() {
            std::panic("attempted to retrieve empty argument parser option value");
        }
        return self.*._opt.value();
    }

    func argument(self: *argument_parser) std::optional[[[]byte]] {
        return self.*._arg;
    }

    func argument_value(self: *argument_parser) []byte {
        if self.*._arg.is_empty() {
            std::panic("attempted to retrieve empty argument parser argument value");
        }
        return self.*._arg.value();
    }
}
