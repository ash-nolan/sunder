namespace std;
import "std/core.sunder";
import "sys";

struct argument_iterator {
    var _argv: **byte;
    var _index: std::optional[[usize]];

    # Initialize an argument iterator using the arguments provided by the
    # hosted environment at program startup.
    #
    # The behavior of this function is implementation defined for programs
    # executing in a freestanding environment. The behavior of this function is
    # implementation defined if the Sunder `main` function was not used as the
    # program entry point.
    func init() argument_iterator {
        return argument_iterator::init_from_argv(sys::argv);
    }

    # Initialize an argument iterator from a C-style argument vector. The
    # provided argv *must* contain a NULL-terminated list of NUL-terminated
    # strings in accordance ISO/IEC 9899:1999 section 5.1.2.2.1.
    func init_from_argv(argv: **byte) argument_iterator {
        return (:argument_iterator){
            ._argv = argv,
            ._index = std::optional[[usize]]::EMPTY
        };
    }

    func advance(self: *argument_iterator) bool {
        if self.*._index.is_empty() {
            self.*._index = std::optional[[usize]]::init_value(0); # start-of-iteration
        }
        else {
            self.*._index = std::optional[[usize]]::init_value(self.*._index.value() + 1);
        }

        var arg = std::ptr[[*byte]]::add(self.*._argv, self.*._index.value());
        if *arg == std::ptr[[byte]]::NULL {
            return false; # end of iteration
        }

        return true;
    }

    func current(self: *argument_iterator) []byte {
        if self.*._index.is_empty() {
            std::panic("invalid iterator");
        }

        var arg = std::ptr[[*byte]]::add(self.*._argv, self.*._index.value());
        if *arg == std::ptr[[byte]]::NULL {
            std::panic("invalid iterator");
        }

        return std::cstr::data(*arg);
    }
}

struct argument_parser {
    var _options: [][]byte;
    var _iterator: argument_iterator;
    var _verbatim: bool;
    var _opt: std::optional[[[]byte]];
    var _arg: std::optional[[[]byte]];

    # Initialize an argument parser using using the arguments provided by the
    # hosted environment at program startup. The first argument (program name)
    # is skipped and *not* treated as an argument by the parser.
    #
    # The behavior of this function is implementation defined for programs
    # executing in a freestanding environment. The behavior of this function is
    # implementation defined if the Sunder `main` function was not used as the
    # program entry point.
    func init(options: [][]byte) argument_parser {
        return std::argument_parser::init_from_argv(options, sys::argv);
    }

    # Initialize an argument parser from a C-style argument vector. The
    # provided argv *must* contain a NULL-terminated list of NUL-terminated
    # strings in accordance ISO/IEC 9899:1999 section 5.1.2.2.1.
    func init_from_argv(options: [][]byte, argv: **byte) argument_parser {
        var self = (:argument_parser){
            ._options = options,
            ._iterator = std::argument_iterator::init_from_argv(argv),
            ._verbatim = false,
            ._opt = std::optional[[[]byte]]::EMPTY,
            ._arg = std::optional[[[]byte]]::EMPTY
        };

        # Skip past the first argument (program name).
        self._iterator.advance();

        return self;
    }

    func advance(self: *argument_parser) bool {
        self.*._opt = std::optional[[[]byte]]::EMPTY;
        self.*._arg = std::optional[[[]byte]]::EMPTY;

        if not self.*._iterator.advance() {
            return false;
        }

        var str = self.*._iterator.current();
        if self.*._verbatim {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # The argument "--" signals that all following arguments should be
        # interpreted verbatim and not parsed as option strings.
        if std::str::eq(str, "--") {
            self.*._verbatim = true;
            return self.*.advance();
        }

        # The argument "-" is *not* treated as the start of an option string
        # since "-" is traditionally used to denote the standard input file.
        if std::str::eq(str, "-") {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # Positional argument.
        if not std::str::starts_with(str, "-") {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # Option strings of the form "-<option>", "--<option>", etc. Remove the
        # leading dashes so that `str` contains only the text of the option.
        for std::str::starts_with(str, "-") {
            str = str[countof("-"):countof(str)];
        }

        var should_parse_arg = false;
        var idx = std::optional[[usize]]::EMPTY;
        for i in countof(self.*._options) {
            should_parse_arg = false;
            var opt = self.*._options[i];

            if std::str::ends_with(opt, ":") { # Required argument.
                opt = str[0 : countof(opt) - 1];
                should_parse_arg = true;
            }

            if std::str::eq(str, opt) {
                idx = std::optional[[usize]]::init_value(i);
                break;
            }
        }
        if idx.is_empty() {
            std::print_format_line(
                std::err(),
                "error: unrecognized option `{}`",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&str)]);
            std::exit(std::EXIT_FAILURE);
        }

        self.*._opt = std::optional[[[]byte]]::init_value(str);
        if not should_parse_arg {
            return true;
        }

        if not self.*._iterator.advance() {
            std::print_format_line(
                std::err(),
                "error: missing required argument for option `{}`",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&str)]);
            std::exit(std::EXIT_FAILURE);
        }
        self.*._arg = std::optional[[[]byte]]::init_value(self.*._iterator.current());
        return true;
    }

    func check_option(self: *argument_parser, opt: []byte) bool {
        if self.*._opt.is_empty() {
            return false;
        }
        return std::str::eq(self.*._opt.value(), opt);
    }

    func option(self: *argument_parser) std::optional[[[]byte]] {
        return self.*._opt;
    }

    func option_value(self: *argument_parser) []byte {
        if self.*._opt.is_empty() {
            std::panic("attempted to retrieve empty argument parser option value");
        }
        return self.*._opt.value();
    }

    func argument(self: *argument_parser) std::optional[[[]byte]] {
        return self.*._arg;
    }

    func argument_value(self: *argument_parser) []byte {
        if self.*._arg.is_empty() {
            std::panic("attempted to retrieve empty argument parser argument value");
        }
        return self.*._arg.value();
    }
}
