namespace std;
import "std/core.sunder";
import "sys";

# Iterate over a program argument list.
#
# Example:
#   # Iterate over the program arguments, starting with argument zero (i.e. the
#   # program name).
#   var iter = std::argument_iterator::init();
#   for iter.advance() {
#       std::print_line(std::out(), iter.current());
#   }
struct argument_iterator {
    var _argv: **byte;
    var _index: std::optional[[usize]];

    # Initialize an argument iterator using the program arguments provided by
    # the hosted environment at program startup.
    #
    # The behavior of this function is implementation defined for programs
    # executing in a freestanding environment. The behavior of this function is
    # implementation defined if the Sunder `main` function was not used as the
    # program entry point.
    func init() argument_iterator {
        return argument_iterator::init_from_argv(sys::argv);
    }

    # Initialize an argument iterator from a C-style argument vector. The
    # provided argv *must* contain a NULL-terminated list of NUL-terminated
    # strings in accordance ISO/IEC 9899:1999 section 5.1.2.2.1.
    func init_from_argv(argv: **byte) argument_iterator {
        return (:argument_iterator){
            ._argv = argv,
            ._index = std::optional[[usize]]::EMPTY
        };
    }

    func advance(self: *argument_iterator) bool {
        if self.*._index.is_empty() {
            self.*._index = std::optional[[usize]]::init_value(0); # start-of-iteration
        }
        else {
            self.*._index = std::optional[[usize]]::init_value(self.*._index.value() + 1);
        }

        var arg = std::ptr[[*byte]]::add(self.*._argv, self.*._index.value());
        if *arg == std::ptr[[byte]]::NULL {
            return false; # end of iteration
        }

        return true;
    }

    func current(self: *argument_iterator) []byte {
        if self.*._index.is_empty() {
            std::panic("invalid iterator");
        }

        var arg = std::ptr[[*byte]]::add(self.*._argv, self.*._index.value());
        if *arg == std::ptr[[byte]]::NULL {
            std::panic("invalid iterator");
        }

        return std::cstr::data(*arg);
    }
}

# Parse a program argument list.
#
# Initializer functions are provided with the `options` list containing strings
# that will be treated as option flags when parsed. Parsed options may start
# with any number of dashes, so `-foo`, `--foo`, and `---foo` are all parsed as
# the option string "foo". An option string may contain a trailing ':'
# character, signifying that the option requires an additional option argument.
# If the argument "--" is encountered, then it will be skipped and all
# subsequent program arguments will be parsed as positional arguments.
#
# Example:
#   var parser = std::argument_parser::init((:[][]byte)[
#       "abc",
#       "def:"
#   ]);
#
#   for parser.advance() {
#       if parser.check_option("abc") {
#           var opt = parser.option_value();
#           std::print_format_line(
#               std::out(),
#               "Option `{}`",
#               (:[]std::formatter)[std::formatter::init[[[]byte]](&opt)]);
#           continue;
#       }
#
#       if parser.check_option("def") {
#           var opt = parser.option_value();
#           var arg = parser.argument_value();
#           std::print_format_line(
#               std::out(),
#               "Option `{}` with required argument `{}`",
#               (:[]std::formatter)[
#                   std::formatter::init[[[]byte]](&opt),
#                   std::formatter::init[[[]byte]](&arg)]);
#           continue;
#       }
#
#       var argument = parser.argument_value();
#       std::print_format_line(
#           std::out(),
#           "Positional argument `{}`",
#           (:[]std::formatter)[std::formatter::init[[[]byte]](&argument)]);
#    }
#
# Example output:
#   $ sunder-run example.sunder --abc foo --def bar baz -- --abc
#   Option `abc`
#   Positional argument `foo`
#   Option `def` with required argument `bar`
#   Positional argument `baz`
#   Positional argument `--abc`
struct argument_parser {
    var _options: [][]byte;
    var _iterator: argument_iterator;
    var _verbatim: bool;
    var _opt: std::optional[[[]byte]];
    var _arg: std::optional[[[]byte]];

    # Initialize an argument parser using using the arguments provided by the
    # hosted environment at program startup. The first argument (program name)
    # is skipped and *not* treated as an argument by the parser.
    #
    # The behavior of this function is implementation defined for programs
    # executing in a freestanding environment. The behavior of this function is
    # implementation defined if the Sunder `main` function was not used as the
    # program entry point.
    func init(options: [][]byte) argument_parser {
        return std::argument_parser::init_from_argv(options, sys::argv);
    }

    # Initialize an argument parser from a C-style argument vector. The
    # provided argv *must* contain a NULL-terminated list of NUL-terminated
    # strings in accordance ISO/IEC 9899:1999 section 5.1.2.2.1.
    func init_from_argv(options: [][]byte, argv: **byte) argument_parser {
        var self = (:argument_parser){
            ._options = options,
            ._iterator = std::argument_iterator::init_from_argv(argv),
            ._verbatim = false,
            ._opt = std::optional[[[]byte]]::EMPTY,
            ._arg = std::optional[[[]byte]]::EMPTY
        };

        # Skip past the first argument (program name).
        self._iterator.advance();

        return self;
    }

    func advance(self: *argument_parser) bool {
        self.*._opt = std::optional[[[]byte]]::EMPTY;
        self.*._arg = std::optional[[[]byte]]::EMPTY;

        if not self.*._iterator.advance() {
            return false;
        }

        var str = self.*._iterator.current();
        if self.*._verbatim {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # The argument "--" signals that all following arguments should be
        # interpreted verbatim and not parsed as option strings.
        if std::str::eq(str, "--") {
            self.*._verbatim = true;
            return self.*.advance();
        }

        # The argument "-" is *not* treated as the start of an option string
        # since "-" is traditionally used to denote the standard input file.
        if std::str::eq(str, "-") {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # Positional argument.
        if not std::str::starts_with(str, "-") {
            self.*._arg = std::optional[[[]byte]]::init_value(str);
            return true;
        }

        # Option strings of the form "-<option>", "--<option>", etc. Remove the
        # leading dashes so that `str` contains only the text of the option.
        for std::str::starts_with(str, "-") {
            str = str[countof("-"):countof(str)];
        }

        var should_parse_arg = false;
        var idx = std::optional[[usize]]::EMPTY;
        for i in countof(self.*._options) {
            should_parse_arg = false;
            var opt = self.*._options[i];

            if std::str::ends_with(opt, ":") { # Required argument.
                opt = str[0 : countof(opt) - 1];
                should_parse_arg = true;
            }

            if std::str::eq(str, opt) {
                idx = std::optional[[usize]]::init_value(i);
                break;
            }
        }
        if idx.is_empty() {
            std::print_format_line(
                std::err(),
                "error: unrecognized option `{}`",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&str)]);
            std::exit(std::EXIT_FAILURE);
        }

        self.*._opt = std::optional[[[]byte]]::init_value(str);
        if not should_parse_arg {
            return true;
        }

        if not self.*._iterator.advance() {
            std::print_format_line(
                std::err(),
                "error: missing required argument for option `{}`",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&str)]);
            std::exit(std::EXIT_FAILURE);
        }
        self.*._arg = std::optional[[[]byte]]::init_value(self.*._iterator.current());
        return true;
    }

    # Returns true if `opt` is the current parsed option.
    func check_option(self: *argument_parser, opt: []byte) bool {
        if self.*._opt.is_empty() {
            return false;
        }
        return std::str::eq(self.*._opt.value(), opt);
    }

    # Returns the current option if an option was parsed.
    func option(self: *argument_parser) std::optional[[[]byte]] {
        return self.*._opt;
    }

    # Convenience function that retrieves the value from the optional returned
    # by `std::argument_parser::option`.
    func option_value(self: *argument_parser) []byte {
        if self.*._opt.is_empty() {
            std::panic("attempted to retrieve empty argument parser option value");
        }
        return self.*._opt.value();
    }

    # Returns the current argument.
    # Empty for options with no required argument.
    # Non-empty for options with a required argument.
    # Non-empty for positional parameters.
    func argument(self: *argument_parser) std::optional[[[]byte]] {
        return self.*._arg;
    }

    # Convenience function that retrieves the value from the optional returned
    # by `std::argument_parser::argument`.
    func argument_value(self: *argument_parser) []byte {
        if self.*._arg.is_empty() {
            std::panic("attempted to retrieve empty argument parser argument value");
        }
        return self.*._arg.value();
    }
}
