# Brainfuck interpreter written in Sunder.
#
# See https://esolangs.org/wiki/Brainfuck for an overview of the brainfuck
# language. This implementation uses a 30,000 cell tape with 8-bit wrapping
# cells. No cell update is performed upon reading EOF with the , operation.
import "std";
import "sys/sys.sunder";

# A buffer size of 0x10000 is large enough to fit both GitHub user rdebath's
# bitwidth.b, Erik Bosman's mandelbrot.b, and Linus Akesson's life.b.
var source: [0x10000]byte = (:[0x10000]byte)[0...];

var cells: [30000]u8 = (:[30000]u8)[0...];
var stack: [4096]usize = (:[4096]usize)[0...];

var cells_index: usize = 0;
var stack_index: usize = 0;

func main() void {
    if sys::argc != 2 {
        var progname: std::str =
            std::str::init(std::cstr::to_bytes(*sys::argv));
        var expected: std::int[[:usize]] = std::int[[:usize]]::init(1);
        var received: std::int[[:usize]] =
            std::int[[:usize]]::init(sys::argc - 1);
        std::print_format_line(
            std::err(),
            "{}: invalid number of arguments (expected {}, received {})",
            (:[]std::formatter)[
                std::formatter::init[[:std::str]](&progname),
                std::formatter::init[[:std::int[[:usize]]]](&expected),
                std::formatter::init[[:std::int[[:usize]]]](&received)]);
        std::exit(std::EXIT_FAILURE);
    }

    var path: *byte = *std::cptr::add[[:*byte]](sys::argv, 1);
    var open_result: std::result[[:std::fs::file, :std::fs::error]] =
        std::fs::file::open(std::cstr::to_bytes(path), std::fs::OPEN_READ);
    if open_result.is_error() {
        var p: std::str = std::str::init(std::cstr::to_bytes(path));
        var e: std::fs::error = open_result.error();
        std::print_format_line(
            std::err(),
            "{}: {}",
            (:[]std::formatter)[
                std::formatter::init[[:std::str]](&p),
                std::formatter::init[[:std::fs::error]](&e)]);
        std::exit(std::EXIT_FAILURE);
    }
    var file: std::fs::file = open_result.value();

    # Assume the user-provided source will fit into countof(source) bytes.
    var read_result: std::result[[:usize, :[]byte]] =
        file.read(source[0:countof(source)]);
    if read_result.is_error() {
        var p: std::str = std::str::init(std::cstr::to_bytes(path));
        var e: std::str = std::str::init(read_result.error());
        std::print_format_line(
            std::err(),
            "{}: {}",
            (:[]std::formatter)[
                std::formatter::init[[:std::str]](&p),
                std::formatter::init[[:std::str]](&e)]);
        file.close();
        std::exit(std::EXIT_FAILURE);
    }
    var source_size: usize = read_result.value();

    var reader: std::reader = std::input();
    var source_index: usize = 0;
    for source_index < source_size {
        var cur: byte = source[source_index];

        if cur == '>' {
            cells_index = cells_index + 1;
            source_index = source_index + 1;
        }
        elif cur == '<' {
            cells_index = cells_index - 1;
            source_index = source_index + 1;
        }
        elif cur == '+' {
            if cells[cells_index] == 0xFF {
                cells[cells_index] = 0x00;
            }
            else {
                cells[cells_index] = cells[cells_index] + 1;
            }
            source_index = source_index + 1;
        }
        elif cur == '-' {
            if cells[cells_index] == 0x00 {
                cells[cells_index] = 0xFF;
            }
            else {
                cells[cells_index] = cells[cells_index] - 1;
            }
            source_index = source_index + 1;
        }
        elif cur == '.' {
            std::print(std::out(), (:[]byte){(:*byte)&cells[cells_index], 1});
            source_index = source_index + 1;
        }
        elif cur == ',' {
            var b: byte = 0;
            read_result = reader.read((:[]byte){&b, 1});
            if read_result.value() != 0 { # Only update on non-EOF.
               cells[cells_index] = (:u8)b;
            }
            source_index = source_index + 1;
        }
        elif cur == '[' {
            if cells[cells_index] == 0 {
                var depth: usize = 1;
                for depth > 0 {
                    source_index = source_index + 1;
                    if source[source_index] == '[' {
                        depth = depth + 1;
                    }
                    if source[source_index] == ']' {
                        depth = depth - 1;
                    }
                }
                source_index = source_index + 1;
            } else {
                stack[stack_index] = source_index;
                stack_index = stack_index + 1;
                source_index = source_index + 1;
            }
        }
        elif cur == ']' {
            stack_index = stack_index - 1;
            source_index = stack[stack_index];
        }
        else {
            source_index = source_index + 1;
        }
    }

    file.close();
}
