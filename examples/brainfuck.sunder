# Brainfuck interpreter written in Sunder.
#
# See https://esolangs.org/wiki/Brainfuck for an overview of the brainfuck
# language. This implementation uses a 30,000 cell tape with 8-bit wrapping
# cells. No cell update is performed upon reading EOF with the , operation.
import "std";
import "sys";

var cells = (:[30000]u8)[0...];
var cells_index: usize = 0;

func main() void {
    var progname = std::cstr::data(*sys::argv);
    var path = std::optional[[[]byte]]::init_empty();

    var parser = std::argument_parser::init((:[][]byte)[]);
    for parser.advance() {
        if path.is_value() {
            std::print_format_line(
                std::err(),
                "{}: multiple files specified",
                (:[]std::formatter)[
                    std::formatter::init[[[]byte]](&progname)]);
            std::exit(std::EXIT_FAILURE);
        }
        path = std::optional[[[]byte]]::init_value(parser.argument_value());
    }

    if path.is_empty() {
        std::print_format_line(
            std::err(),
            "{}: no file specified",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&progname)]);
        std::exit(std::EXIT_FAILURE);
    }
    var path = path.value();

    var result = std::file::open(path, std::file::OPEN_READ);
    if result.is_error() {
        var error = result.error();
        std::print_format_line(
            std::err(),
            "{}: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&path),
                std::formatter::init[[[]byte]](&error)]);
        std::exit(std::EXIT_FAILURE);
    }

    var file = result.value();
    defer {
        file.close();
    }

    var allocator = std::general_allocator::init();
    defer {
        allocator.fini();
    }
    var allocator = std::allocator::init[[typeof(allocator)]](&allocator);

    var result = std::read_all(std::reader::init[[std::file]](&file), allocator);
    if result.is_error() {
        var error = result.error();
        std::print_format_line(
            std::err(),
            "{}: {}",
            (:[]std::formatter)[
                std::formatter::init[[[]byte]](&path),
                std::formatter::init[[[]byte]](&error)]);
        std::exit(std::EXIT_FAILURE);
    }
    var source = result.value();
    var source_size: usize = countof(source);

    var stack = std::vector[[usize]]::init(allocator);
    var source_index: usize = 0;
    for source_index < source_size {
        var cur: byte = source[source_index];

        if cur == '>' {
            cells_index = cells_index + 1;
            source_index = source_index + 1;
            continue;
        }
        if cur == '<' {
            cells_index = cells_index - 1;
            source_index = source_index + 1;
            continue;
        }
        if cur == '+' {
            cells[cells_index] = (:u8)((:ssize)cells[cells_index] + 1);
            source_index = source_index + 1;
            continue;
        }
        if cur == '-' {
            cells[cells_index] = (:u8)((:ssize)cells[cells_index] - 1);
            source_index = source_index + 1;
            continue;
        }
        if cur == '.' {
            std::print(std::out(), (:[]byte){(:*byte)&cells[cells_index], 1});
            source_index = source_index + 1;
            continue;
        }
        if cur == ',' {
            var b: byte = 0;
            var result = std::input_reader::the().*.read((:[]byte){&b, 1});
            if result.value() != 0 { # Only update on non-EOF.
               cells[cells_index] = (:u8)b;
            }
            source_index = source_index + 1;
            continue;
        }
        if cur == '[' {
            if cells[cells_index] == 0 {
                var depth: usize = 1;
                for depth > 0 {
                    source_index = source_index + 1;
                    if source[source_index] == '[' {
                        depth = depth + 1;
                    }
                    if source[source_index] == ']' {
                        depth = depth - 1;
                    }
                }
            } else {
                stack.push(source_index);
            }
            source_index = source_index + 1;
            continue;
        }
        if cur == ']' {
            source_index = stack.pop();
            continue;
        }
        source_index = source_index + 1;
    }
}
