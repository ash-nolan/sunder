# Sum integers from standard input until an end-of-file condition is reached.
import "std";

func main() void {
    var allocator = std::general_allocator::init();
    defer {
        allocator.fini();
    }
    var allocator = std::allocator::init[[typeof(allocator)]](&allocator);

    var sum = std::big_integer::init(allocator);
    defer {
        sum.fini();
    }

    for true {
        var result = std::read_line(std::input(), allocator);
        if result.is_error() {
            std::print_line(std::err(), result.error().*.data);
            std::exit(std::EXIT_FAILURE);
        }

        var optional = result.value();
        if optional.is_empty() {
            # End-of-input.
            break;
        }
        defer {
            std::slice[[byte]]::delete(allocator, optional.value());
        }

        if countof(optional.value()) == 0 {
            # Skip line consisting of a single '\n'.
            continue;
        }

        var result = std::big_integer::init_from_str(allocator, optional.value(), 0);
        if result.is_error() {
            std::print_line(std::err(), result.error().*.data);
            std::exit(std::EXIT_FAILURE);
        }
        var int = result.value();
        defer {
            int.fini();
        }

        std::big_integer::add(&sum, &sum, &int);
    }

    std::print_format_line(std::out(), "{}", (:[]std::formatter)[std::formatter::init[[std::big_integer]](&sum)]);
}
